// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package stackit

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/stackitcloud/pulumi-stackit/sdk/go/stackit/internal"
)

// ## Example Usage
type KmsKey struct {
	pulumi.CustomResourceState

	// The access scope of the key. Default is `PUBLIC`. Possible values are: `PUBLIC`, `SNA`.
	AccessScope pulumi.StringOutput `pulumi:"accessScope"`
	// The encryption algorithm that the key will use to encrypt data. Possible values are: `aes256Gcm`, `rsa2048OaepSha256`, `rsa3072OaepSha256`, `rsa4096OaepSha256`, `rsa4096OaepSha512`, `hmacSha256`, `hmacSha384`, `hmacSha512`, `ecdsaP256Sha256`, `ecdsaP384Sha384`, `ecdsaP521Sha512`.
	Algorithm pulumi.StringOutput `pulumi:"algorithm"`
	// A user chosen description to distinguish multiple keys
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The display name to distinguish multiple keys
	DisplayName pulumi.StringOutput `pulumi:"displayName"`
	// States whether versions can be created or only imported.
	ImportOnly pulumi.BoolOutput `pulumi:"importOnly"`
	// The ID of the key
	KeyId pulumi.StringOutput `pulumi:"keyId"`
	// The ID of the associated keyring
	KeyringId pulumi.StringOutput `pulumi:"keyringId"`
	// STACKIT project ID to which the key is associated.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// The underlying system that is responsible for protecting the key material. Possible values are: `software`.
	Protection pulumi.StringOutput `pulumi:"protection"`
	// The purpose for which the key will be used. Possible values are: `symmetricEncryptDecrypt`, `asymmetricEncryptDecrypt`, `messageAuthenticationCode`, `asymmetricSignVerify`.
	Purpose pulumi.StringOutput `pulumi:"purpose"`
	// The resource region. If not defined, the provider region is used.
	Region pulumi.StringOutput `pulumi:"region"`
}

// NewKmsKey registers a new resource with the given unique name, arguments, and options.
func NewKmsKey(ctx *pulumi.Context,
	name string, args *KmsKeyArgs, opts ...pulumi.ResourceOption) (*KmsKey, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Algorithm == nil {
		return nil, errors.New("invalid value for required argument 'Algorithm'")
	}
	if args.DisplayName == nil {
		return nil, errors.New("invalid value for required argument 'DisplayName'")
	}
	if args.KeyringId == nil {
		return nil, errors.New("invalid value for required argument 'KeyringId'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	if args.Protection == nil {
		return nil, errors.New("invalid value for required argument 'Protection'")
	}
	if args.Purpose == nil {
		return nil, errors.New("invalid value for required argument 'Purpose'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource KmsKey
	err := ctx.RegisterResource("stackit:index/kmsKey:KmsKey", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKmsKey gets an existing KmsKey resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKmsKey(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KmsKeyState, opts ...pulumi.ResourceOption) (*KmsKey, error) {
	var resource KmsKey
	err := ctx.ReadResource("stackit:index/kmsKey:KmsKey", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KmsKey resources.
type kmsKeyState struct {
	// The access scope of the key. Default is `PUBLIC`. Possible values are: `PUBLIC`, `SNA`.
	AccessScope *string `pulumi:"accessScope"`
	// The encryption algorithm that the key will use to encrypt data. Possible values are: `aes256Gcm`, `rsa2048OaepSha256`, `rsa3072OaepSha256`, `rsa4096OaepSha256`, `rsa4096OaepSha512`, `hmacSha256`, `hmacSha384`, `hmacSha512`, `ecdsaP256Sha256`, `ecdsaP384Sha384`, `ecdsaP521Sha512`.
	Algorithm *string `pulumi:"algorithm"`
	// A user chosen description to distinguish multiple keys
	Description *string `pulumi:"description"`
	// The display name to distinguish multiple keys
	DisplayName *string `pulumi:"displayName"`
	// States whether versions can be created or only imported.
	ImportOnly *bool `pulumi:"importOnly"`
	// The ID of the key
	KeyId *string `pulumi:"keyId"`
	// The ID of the associated keyring
	KeyringId *string `pulumi:"keyringId"`
	// STACKIT project ID to which the key is associated.
	ProjectId *string `pulumi:"projectId"`
	// The underlying system that is responsible for protecting the key material. Possible values are: `software`.
	Protection *string `pulumi:"protection"`
	// The purpose for which the key will be used. Possible values are: `symmetricEncryptDecrypt`, `asymmetricEncryptDecrypt`, `messageAuthenticationCode`, `asymmetricSignVerify`.
	Purpose *string `pulumi:"purpose"`
	// The resource region. If not defined, the provider region is used.
	Region *string `pulumi:"region"`
}

type KmsKeyState struct {
	// The access scope of the key. Default is `PUBLIC`. Possible values are: `PUBLIC`, `SNA`.
	AccessScope pulumi.StringPtrInput
	// The encryption algorithm that the key will use to encrypt data. Possible values are: `aes256Gcm`, `rsa2048OaepSha256`, `rsa3072OaepSha256`, `rsa4096OaepSha256`, `rsa4096OaepSha512`, `hmacSha256`, `hmacSha384`, `hmacSha512`, `ecdsaP256Sha256`, `ecdsaP384Sha384`, `ecdsaP521Sha512`.
	Algorithm pulumi.StringPtrInput
	// A user chosen description to distinguish multiple keys
	Description pulumi.StringPtrInput
	// The display name to distinguish multiple keys
	DisplayName pulumi.StringPtrInput
	// States whether versions can be created or only imported.
	ImportOnly pulumi.BoolPtrInput
	// The ID of the key
	KeyId pulumi.StringPtrInput
	// The ID of the associated keyring
	KeyringId pulumi.StringPtrInput
	// STACKIT project ID to which the key is associated.
	ProjectId pulumi.StringPtrInput
	// The underlying system that is responsible for protecting the key material. Possible values are: `software`.
	Protection pulumi.StringPtrInput
	// The purpose for which the key will be used. Possible values are: `symmetricEncryptDecrypt`, `asymmetricEncryptDecrypt`, `messageAuthenticationCode`, `asymmetricSignVerify`.
	Purpose pulumi.StringPtrInput
	// The resource region. If not defined, the provider region is used.
	Region pulumi.StringPtrInput
}

func (KmsKeyState) ElementType() reflect.Type {
	return reflect.TypeOf((*kmsKeyState)(nil)).Elem()
}

type kmsKeyArgs struct {
	// The access scope of the key. Default is `PUBLIC`. Possible values are: `PUBLIC`, `SNA`.
	AccessScope *string `pulumi:"accessScope"`
	// The encryption algorithm that the key will use to encrypt data. Possible values are: `aes256Gcm`, `rsa2048OaepSha256`, `rsa3072OaepSha256`, `rsa4096OaepSha256`, `rsa4096OaepSha512`, `hmacSha256`, `hmacSha384`, `hmacSha512`, `ecdsaP256Sha256`, `ecdsaP384Sha384`, `ecdsaP521Sha512`.
	Algorithm string `pulumi:"algorithm"`
	// A user chosen description to distinguish multiple keys
	Description *string `pulumi:"description"`
	// The display name to distinguish multiple keys
	DisplayName string `pulumi:"displayName"`
	// States whether versions can be created or only imported.
	ImportOnly *bool `pulumi:"importOnly"`
	// The ID of the associated keyring
	KeyringId string `pulumi:"keyringId"`
	// STACKIT project ID to which the key is associated.
	ProjectId string `pulumi:"projectId"`
	// The underlying system that is responsible for protecting the key material. Possible values are: `software`.
	Protection string `pulumi:"protection"`
	// The purpose for which the key will be used. Possible values are: `symmetricEncryptDecrypt`, `asymmetricEncryptDecrypt`, `messageAuthenticationCode`, `asymmetricSignVerify`.
	Purpose string `pulumi:"purpose"`
	// The resource region. If not defined, the provider region is used.
	Region *string `pulumi:"region"`
}

// The set of arguments for constructing a KmsKey resource.
type KmsKeyArgs struct {
	// The access scope of the key. Default is `PUBLIC`. Possible values are: `PUBLIC`, `SNA`.
	AccessScope pulumi.StringPtrInput
	// The encryption algorithm that the key will use to encrypt data. Possible values are: `aes256Gcm`, `rsa2048OaepSha256`, `rsa3072OaepSha256`, `rsa4096OaepSha256`, `rsa4096OaepSha512`, `hmacSha256`, `hmacSha384`, `hmacSha512`, `ecdsaP256Sha256`, `ecdsaP384Sha384`, `ecdsaP521Sha512`.
	Algorithm pulumi.StringInput
	// A user chosen description to distinguish multiple keys
	Description pulumi.StringPtrInput
	// The display name to distinguish multiple keys
	DisplayName pulumi.StringInput
	// States whether versions can be created or only imported.
	ImportOnly pulumi.BoolPtrInput
	// The ID of the associated keyring
	KeyringId pulumi.StringInput
	// STACKIT project ID to which the key is associated.
	ProjectId pulumi.StringInput
	// The underlying system that is responsible for protecting the key material. Possible values are: `software`.
	Protection pulumi.StringInput
	// The purpose for which the key will be used. Possible values are: `symmetricEncryptDecrypt`, `asymmetricEncryptDecrypt`, `messageAuthenticationCode`, `asymmetricSignVerify`.
	Purpose pulumi.StringInput
	// The resource region. If not defined, the provider region is used.
	Region pulumi.StringPtrInput
}

func (KmsKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kmsKeyArgs)(nil)).Elem()
}

type KmsKeyInput interface {
	pulumi.Input

	ToKmsKeyOutput() KmsKeyOutput
	ToKmsKeyOutputWithContext(ctx context.Context) KmsKeyOutput
}

func (*KmsKey) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsKey)(nil)).Elem()
}

func (i *KmsKey) ToKmsKeyOutput() KmsKeyOutput {
	return i.ToKmsKeyOutputWithContext(context.Background())
}

func (i *KmsKey) ToKmsKeyOutputWithContext(ctx context.Context) KmsKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsKeyOutput)
}

// KmsKeyArrayInput is an input type that accepts KmsKeyArray and KmsKeyArrayOutput values.
// You can construct a concrete instance of `KmsKeyArrayInput` via:
//
//	KmsKeyArray{ KmsKeyArgs{...} }
type KmsKeyArrayInput interface {
	pulumi.Input

	ToKmsKeyArrayOutput() KmsKeyArrayOutput
	ToKmsKeyArrayOutputWithContext(context.Context) KmsKeyArrayOutput
}

type KmsKeyArray []KmsKeyInput

func (KmsKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KmsKey)(nil)).Elem()
}

func (i KmsKeyArray) ToKmsKeyArrayOutput() KmsKeyArrayOutput {
	return i.ToKmsKeyArrayOutputWithContext(context.Background())
}

func (i KmsKeyArray) ToKmsKeyArrayOutputWithContext(ctx context.Context) KmsKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsKeyArrayOutput)
}

// KmsKeyMapInput is an input type that accepts KmsKeyMap and KmsKeyMapOutput values.
// You can construct a concrete instance of `KmsKeyMapInput` via:
//
//	KmsKeyMap{ "key": KmsKeyArgs{...} }
type KmsKeyMapInput interface {
	pulumi.Input

	ToKmsKeyMapOutput() KmsKeyMapOutput
	ToKmsKeyMapOutputWithContext(context.Context) KmsKeyMapOutput
}

type KmsKeyMap map[string]KmsKeyInput

func (KmsKeyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KmsKey)(nil)).Elem()
}

func (i KmsKeyMap) ToKmsKeyMapOutput() KmsKeyMapOutput {
	return i.ToKmsKeyMapOutputWithContext(context.Background())
}

func (i KmsKeyMap) ToKmsKeyMapOutputWithContext(ctx context.Context) KmsKeyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsKeyMapOutput)
}

type KmsKeyOutput struct{ *pulumi.OutputState }

func (KmsKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsKey)(nil)).Elem()
}

func (o KmsKeyOutput) ToKmsKeyOutput() KmsKeyOutput {
	return o
}

func (o KmsKeyOutput) ToKmsKeyOutputWithContext(ctx context.Context) KmsKeyOutput {
	return o
}

// The access scope of the key. Default is `PUBLIC`. Possible values are: `PUBLIC`, `SNA`.
func (o KmsKeyOutput) AccessScope() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.AccessScope }).(pulumi.StringOutput)
}

// The encryption algorithm that the key will use to encrypt data. Possible values are: `aes256Gcm`, `rsa2048OaepSha256`, `rsa3072OaepSha256`, `rsa4096OaepSha256`, `rsa4096OaepSha512`, `hmacSha256`, `hmacSha384`, `hmacSha512`, `ecdsaP256Sha256`, `ecdsaP384Sha384`, `ecdsaP521Sha512`.
func (o KmsKeyOutput) Algorithm() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.Algorithm }).(pulumi.StringOutput)
}

// A user chosen description to distinguish multiple keys
func (o KmsKeyOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The display name to distinguish multiple keys
func (o KmsKeyOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.DisplayName }).(pulumi.StringOutput)
}

// States whether versions can be created or only imported.
func (o KmsKeyOutput) ImportOnly() pulumi.BoolOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.BoolOutput { return v.ImportOnly }).(pulumi.BoolOutput)
}

// The ID of the key
func (o KmsKeyOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.KeyId }).(pulumi.StringOutput)
}

// The ID of the associated keyring
func (o KmsKeyOutput) KeyringId() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.KeyringId }).(pulumi.StringOutput)
}

// STACKIT project ID to which the key is associated.
func (o KmsKeyOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// The underlying system that is responsible for protecting the key material. Possible values are: `software`.
func (o KmsKeyOutput) Protection() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.Protection }).(pulumi.StringOutput)
}

// The purpose for which the key will be used. Possible values are: `symmetricEncryptDecrypt`, `asymmetricEncryptDecrypt`, `messageAuthenticationCode`, `asymmetricSignVerify`.
func (o KmsKeyOutput) Purpose() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.Purpose }).(pulumi.StringOutput)
}

// The resource region. If not defined, the provider region is used.
func (o KmsKeyOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsKey) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

type KmsKeyArrayOutput struct{ *pulumi.OutputState }

func (KmsKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KmsKey)(nil)).Elem()
}

func (o KmsKeyArrayOutput) ToKmsKeyArrayOutput() KmsKeyArrayOutput {
	return o
}

func (o KmsKeyArrayOutput) ToKmsKeyArrayOutputWithContext(ctx context.Context) KmsKeyArrayOutput {
	return o
}

func (o KmsKeyArrayOutput) Index(i pulumi.IntInput) KmsKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *KmsKey {
		return vs[0].([]*KmsKey)[vs[1].(int)]
	}).(KmsKeyOutput)
}

type KmsKeyMapOutput struct{ *pulumi.OutputState }

func (KmsKeyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KmsKey)(nil)).Elem()
}

func (o KmsKeyMapOutput) ToKmsKeyMapOutput() KmsKeyMapOutput {
	return o
}

func (o KmsKeyMapOutput) ToKmsKeyMapOutputWithContext(ctx context.Context) KmsKeyMapOutput {
	return o
}

func (o KmsKeyMapOutput) MapIndex(k pulumi.StringInput) KmsKeyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *KmsKey {
		return vs[0].(map[string]*KmsKey)[vs[1].(string)]
	}).(KmsKeyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KmsKeyInput)(nil)).Elem(), &KmsKey{})
	pulumi.RegisterInputType(reflect.TypeOf((*KmsKeyArrayInput)(nil)).Elem(), KmsKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KmsKeyMapInput)(nil)).Elem(), KmsKeyMap{})
	pulumi.RegisterOutputType(KmsKeyOutput{})
	pulumi.RegisterOutputType(KmsKeyArrayOutput{})
	pulumi.RegisterOutputType(KmsKeyMapOutput{})
}
