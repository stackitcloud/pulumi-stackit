// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package stackit

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/stackitcloud/pulumi-stackit/sdk/go/stackit/internal"
)

// Network area route resource schema. Must have a `region` specified in the provider configuration.
//
// ## Example Usage
type NetworkAreaRoute struct {
	pulumi.CustomResourceState

	// Labels are key-value string pairs which can be attached to a resource container
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// The network area ID to which the network area route is associated.
	NetworkAreaId pulumi.StringOutput `pulumi:"networkAreaId"`
	// The network area route ID.
	NetworkAreaRouteId pulumi.StringOutput `pulumi:"networkAreaRouteId"`
	// The IP address of the routing system, that will route the prefix configured. Should be a valid IPv4 address.
	NextHop pulumi.StringOutput `pulumi:"nextHop"`
	// STACKIT organization ID to which the network area is associated.
	OrganizationId pulumi.StringOutput `pulumi:"organizationId"`
	// The network, that is reachable though the Next Hop. Should use CIDR notation.
	Prefix pulumi.StringOutput `pulumi:"prefix"`
}

// NewNetworkAreaRoute registers a new resource with the given unique name, arguments, and options.
func NewNetworkAreaRoute(ctx *pulumi.Context,
	name string, args *NetworkAreaRouteArgs, opts ...pulumi.ResourceOption) (*NetworkAreaRoute, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.NetworkAreaId == nil {
		return nil, errors.New("invalid value for required argument 'NetworkAreaId'")
	}
	if args.NextHop == nil {
		return nil, errors.New("invalid value for required argument 'NextHop'")
	}
	if args.OrganizationId == nil {
		return nil, errors.New("invalid value for required argument 'OrganizationId'")
	}
	if args.Prefix == nil {
		return nil, errors.New("invalid value for required argument 'Prefix'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource NetworkAreaRoute
	err := ctx.RegisterResource("stackit:index/networkAreaRoute:NetworkAreaRoute", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNetworkAreaRoute gets an existing NetworkAreaRoute resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNetworkAreaRoute(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NetworkAreaRouteState, opts ...pulumi.ResourceOption) (*NetworkAreaRoute, error) {
	var resource NetworkAreaRoute
	err := ctx.ReadResource("stackit:index/networkAreaRoute:NetworkAreaRoute", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NetworkAreaRoute resources.
type networkAreaRouteState struct {
	// Labels are key-value string pairs which can be attached to a resource container
	Labels map[string]string `pulumi:"labels"`
	// The network area ID to which the network area route is associated.
	NetworkAreaId *string `pulumi:"networkAreaId"`
	// The network area route ID.
	NetworkAreaRouteId *string `pulumi:"networkAreaRouteId"`
	// The IP address of the routing system, that will route the prefix configured. Should be a valid IPv4 address.
	NextHop *string `pulumi:"nextHop"`
	// STACKIT organization ID to which the network area is associated.
	OrganizationId *string `pulumi:"organizationId"`
	// The network, that is reachable though the Next Hop. Should use CIDR notation.
	Prefix *string `pulumi:"prefix"`
}

type NetworkAreaRouteState struct {
	// Labels are key-value string pairs which can be attached to a resource container
	Labels pulumi.StringMapInput
	// The network area ID to which the network area route is associated.
	NetworkAreaId pulumi.StringPtrInput
	// The network area route ID.
	NetworkAreaRouteId pulumi.StringPtrInput
	// The IP address of the routing system, that will route the prefix configured. Should be a valid IPv4 address.
	NextHop pulumi.StringPtrInput
	// STACKIT organization ID to which the network area is associated.
	OrganizationId pulumi.StringPtrInput
	// The network, that is reachable though the Next Hop. Should use CIDR notation.
	Prefix pulumi.StringPtrInput
}

func (NetworkAreaRouteState) ElementType() reflect.Type {
	return reflect.TypeOf((*networkAreaRouteState)(nil)).Elem()
}

type networkAreaRouteArgs struct {
	// Labels are key-value string pairs which can be attached to a resource container
	Labels map[string]string `pulumi:"labels"`
	// The network area ID to which the network area route is associated.
	NetworkAreaId string `pulumi:"networkAreaId"`
	// The IP address of the routing system, that will route the prefix configured. Should be a valid IPv4 address.
	NextHop string `pulumi:"nextHop"`
	// STACKIT organization ID to which the network area is associated.
	OrganizationId string `pulumi:"organizationId"`
	// The network, that is reachable though the Next Hop. Should use CIDR notation.
	Prefix string `pulumi:"prefix"`
}

// The set of arguments for constructing a NetworkAreaRoute resource.
type NetworkAreaRouteArgs struct {
	// Labels are key-value string pairs which can be attached to a resource container
	Labels pulumi.StringMapInput
	// The network area ID to which the network area route is associated.
	NetworkAreaId pulumi.StringInput
	// The IP address of the routing system, that will route the prefix configured. Should be a valid IPv4 address.
	NextHop pulumi.StringInput
	// STACKIT organization ID to which the network area is associated.
	OrganizationId pulumi.StringInput
	// The network, that is reachable though the Next Hop. Should use CIDR notation.
	Prefix pulumi.StringInput
}

func (NetworkAreaRouteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*networkAreaRouteArgs)(nil)).Elem()
}

type NetworkAreaRouteInput interface {
	pulumi.Input

	ToNetworkAreaRouteOutput() NetworkAreaRouteOutput
	ToNetworkAreaRouteOutputWithContext(ctx context.Context) NetworkAreaRouteOutput
}

func (*NetworkAreaRoute) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkAreaRoute)(nil)).Elem()
}

func (i *NetworkAreaRoute) ToNetworkAreaRouteOutput() NetworkAreaRouteOutput {
	return i.ToNetworkAreaRouteOutputWithContext(context.Background())
}

func (i *NetworkAreaRoute) ToNetworkAreaRouteOutputWithContext(ctx context.Context) NetworkAreaRouteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkAreaRouteOutput)
}

// NetworkAreaRouteArrayInput is an input type that accepts NetworkAreaRouteArray and NetworkAreaRouteArrayOutput values.
// You can construct a concrete instance of `NetworkAreaRouteArrayInput` via:
//
//	NetworkAreaRouteArray{ NetworkAreaRouteArgs{...} }
type NetworkAreaRouteArrayInput interface {
	pulumi.Input

	ToNetworkAreaRouteArrayOutput() NetworkAreaRouteArrayOutput
	ToNetworkAreaRouteArrayOutputWithContext(context.Context) NetworkAreaRouteArrayOutput
}

type NetworkAreaRouteArray []NetworkAreaRouteInput

func (NetworkAreaRouteArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkAreaRoute)(nil)).Elem()
}

func (i NetworkAreaRouteArray) ToNetworkAreaRouteArrayOutput() NetworkAreaRouteArrayOutput {
	return i.ToNetworkAreaRouteArrayOutputWithContext(context.Background())
}

func (i NetworkAreaRouteArray) ToNetworkAreaRouteArrayOutputWithContext(ctx context.Context) NetworkAreaRouteArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkAreaRouteArrayOutput)
}

// NetworkAreaRouteMapInput is an input type that accepts NetworkAreaRouteMap and NetworkAreaRouteMapOutput values.
// You can construct a concrete instance of `NetworkAreaRouteMapInput` via:
//
//	NetworkAreaRouteMap{ "key": NetworkAreaRouteArgs{...} }
type NetworkAreaRouteMapInput interface {
	pulumi.Input

	ToNetworkAreaRouteMapOutput() NetworkAreaRouteMapOutput
	ToNetworkAreaRouteMapOutputWithContext(context.Context) NetworkAreaRouteMapOutput
}

type NetworkAreaRouteMap map[string]NetworkAreaRouteInput

func (NetworkAreaRouteMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkAreaRoute)(nil)).Elem()
}

func (i NetworkAreaRouteMap) ToNetworkAreaRouteMapOutput() NetworkAreaRouteMapOutput {
	return i.ToNetworkAreaRouteMapOutputWithContext(context.Background())
}

func (i NetworkAreaRouteMap) ToNetworkAreaRouteMapOutputWithContext(ctx context.Context) NetworkAreaRouteMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkAreaRouteMapOutput)
}

type NetworkAreaRouteOutput struct{ *pulumi.OutputState }

func (NetworkAreaRouteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkAreaRoute)(nil)).Elem()
}

func (o NetworkAreaRouteOutput) ToNetworkAreaRouteOutput() NetworkAreaRouteOutput {
	return o
}

func (o NetworkAreaRouteOutput) ToNetworkAreaRouteOutputWithContext(ctx context.Context) NetworkAreaRouteOutput {
	return o
}

// Labels are key-value string pairs which can be attached to a resource container
func (o NetworkAreaRouteOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *NetworkAreaRoute) pulumi.StringMapOutput { return v.Labels }).(pulumi.StringMapOutput)
}

// The network area ID to which the network area route is associated.
func (o NetworkAreaRouteOutput) NetworkAreaId() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkAreaRoute) pulumi.StringOutput { return v.NetworkAreaId }).(pulumi.StringOutput)
}

// The network area route ID.
func (o NetworkAreaRouteOutput) NetworkAreaRouteId() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkAreaRoute) pulumi.StringOutput { return v.NetworkAreaRouteId }).(pulumi.StringOutput)
}

// The IP address of the routing system, that will route the prefix configured. Should be a valid IPv4 address.
func (o NetworkAreaRouteOutput) NextHop() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkAreaRoute) pulumi.StringOutput { return v.NextHop }).(pulumi.StringOutput)
}

// STACKIT organization ID to which the network area is associated.
func (o NetworkAreaRouteOutput) OrganizationId() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkAreaRoute) pulumi.StringOutput { return v.OrganizationId }).(pulumi.StringOutput)
}

// The network, that is reachable though the Next Hop. Should use CIDR notation.
func (o NetworkAreaRouteOutput) Prefix() pulumi.StringOutput {
	return o.ApplyT(func(v *NetworkAreaRoute) pulumi.StringOutput { return v.Prefix }).(pulumi.StringOutput)
}

type NetworkAreaRouteArrayOutput struct{ *pulumi.OutputState }

func (NetworkAreaRouteArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NetworkAreaRoute)(nil)).Elem()
}

func (o NetworkAreaRouteArrayOutput) ToNetworkAreaRouteArrayOutput() NetworkAreaRouteArrayOutput {
	return o
}

func (o NetworkAreaRouteArrayOutput) ToNetworkAreaRouteArrayOutputWithContext(ctx context.Context) NetworkAreaRouteArrayOutput {
	return o
}

func (o NetworkAreaRouteArrayOutput) Index(i pulumi.IntInput) NetworkAreaRouteOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NetworkAreaRoute {
		return vs[0].([]*NetworkAreaRoute)[vs[1].(int)]
	}).(NetworkAreaRouteOutput)
}

type NetworkAreaRouteMapOutput struct{ *pulumi.OutputState }

func (NetworkAreaRouteMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NetworkAreaRoute)(nil)).Elem()
}

func (o NetworkAreaRouteMapOutput) ToNetworkAreaRouteMapOutput() NetworkAreaRouteMapOutput {
	return o
}

func (o NetworkAreaRouteMapOutput) ToNetworkAreaRouteMapOutputWithContext(ctx context.Context) NetworkAreaRouteMapOutput {
	return o
}

func (o NetworkAreaRouteMapOutput) MapIndex(k pulumi.StringInput) NetworkAreaRouteOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NetworkAreaRoute {
		return vs[0].(map[string]*NetworkAreaRoute)[vs[1].(string)]
	}).(NetworkAreaRouteOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkAreaRouteInput)(nil)).Elem(), &NetworkAreaRoute{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkAreaRouteArrayInput)(nil)).Elem(), NetworkAreaRouteArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkAreaRouteMapInput)(nil)).Elem(), NetworkAreaRouteMap{})
	pulumi.RegisterOutputType(NetworkAreaRouteOutput{})
	pulumi.RegisterOutputType(NetworkAreaRouteArrayOutput{})
	pulumi.RegisterOutputType(NetworkAreaRouteMapOutput{})
}
