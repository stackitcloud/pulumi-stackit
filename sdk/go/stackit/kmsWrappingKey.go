// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package stackit

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/stackitcloud/pulumi-stackit/sdk/go/stackit/internal"
)

// KMS wrapping key resource schema.
//
// ## Example Usage
type KmsWrappingKey struct {
	pulumi.CustomResourceState

	// The access scope of the key. Default is `PUBLIC`. Possible values are: `PUBLIC`, `SNA`.
	AccessScope pulumi.StringOutput `pulumi:"accessScope"`
	// The wrapping algorithm used to wrap the key to import. Possible values are: `rsa2048OaepSha256`, `rsa3072OaepSha256`, `rsa4096OaepSha256`, `rsa4096OaepSha512`, `rsa2048OaepSha256Aes256KeyWrap`, `rsa3072OaepSha256Aes256KeyWrap`, `rsa4096OaepSha256Aes256KeyWrap`, `rsa4096OaepSha512Aes256KeyWrap`.
	Algorithm pulumi.StringOutput `pulumi:"algorithm"`
	// The date and time the creation of the wrapping key was triggered.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// A user chosen description to distinguish multiple wrapping keys.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The display name to distinguish multiple wrapping keys.
	DisplayName pulumi.StringOutput `pulumi:"displayName"`
	// The date and time the wrapping key will expire.
	ExpiresAt pulumi.StringOutput `pulumi:"expiresAt"`
	// The ID of the associated keyring
	KeyringId pulumi.StringOutput `pulumi:"keyringId"`
	// STACKIT project ID to which the keyring is associated.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// The underlying system that is responsible for protecting the key material. Possible values are: `software`.
	Protection pulumi.StringOutput `pulumi:"protection"`
	// The public key of the wrapping key.
	PublicKey pulumi.StringOutput `pulumi:"publicKey"`
	// The purpose for which the key will be used. Possible values are: `wrapSymmetricKey`, `wrapAsymmetricKey`.
	Purpose pulumi.StringOutput `pulumi:"purpose"`
	// The resource region. If not defined, the provider region is used.
	Region pulumi.StringOutput `pulumi:"region"`
	// The ID of the wrapping key
	WrappingKeyId pulumi.StringOutput `pulumi:"wrappingKeyId"`
}

// NewKmsWrappingKey registers a new resource with the given unique name, arguments, and options.
func NewKmsWrappingKey(ctx *pulumi.Context,
	name string, args *KmsWrappingKeyArgs, opts ...pulumi.ResourceOption) (*KmsWrappingKey, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Algorithm == nil {
		return nil, errors.New("invalid value for required argument 'Algorithm'")
	}
	if args.DisplayName == nil {
		return nil, errors.New("invalid value for required argument 'DisplayName'")
	}
	if args.KeyringId == nil {
		return nil, errors.New("invalid value for required argument 'KeyringId'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	if args.Protection == nil {
		return nil, errors.New("invalid value for required argument 'Protection'")
	}
	if args.Purpose == nil {
		return nil, errors.New("invalid value for required argument 'Purpose'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource KmsWrappingKey
	err := ctx.RegisterResource("stackit:index/kmsWrappingKey:KmsWrappingKey", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKmsWrappingKey gets an existing KmsWrappingKey resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKmsWrappingKey(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KmsWrappingKeyState, opts ...pulumi.ResourceOption) (*KmsWrappingKey, error) {
	var resource KmsWrappingKey
	err := ctx.ReadResource("stackit:index/kmsWrappingKey:KmsWrappingKey", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KmsWrappingKey resources.
type kmsWrappingKeyState struct {
	// The access scope of the key. Default is `PUBLIC`. Possible values are: `PUBLIC`, `SNA`.
	AccessScope *string `pulumi:"accessScope"`
	// The wrapping algorithm used to wrap the key to import. Possible values are: `rsa2048OaepSha256`, `rsa3072OaepSha256`, `rsa4096OaepSha256`, `rsa4096OaepSha512`, `rsa2048OaepSha256Aes256KeyWrap`, `rsa3072OaepSha256Aes256KeyWrap`, `rsa4096OaepSha256Aes256KeyWrap`, `rsa4096OaepSha512Aes256KeyWrap`.
	Algorithm *string `pulumi:"algorithm"`
	// The date and time the creation of the wrapping key was triggered.
	CreatedAt *string `pulumi:"createdAt"`
	// A user chosen description to distinguish multiple wrapping keys.
	Description *string `pulumi:"description"`
	// The display name to distinguish multiple wrapping keys.
	DisplayName *string `pulumi:"displayName"`
	// The date and time the wrapping key will expire.
	ExpiresAt *string `pulumi:"expiresAt"`
	// The ID of the associated keyring
	KeyringId *string `pulumi:"keyringId"`
	// STACKIT project ID to which the keyring is associated.
	ProjectId *string `pulumi:"projectId"`
	// The underlying system that is responsible for protecting the key material. Possible values are: `software`.
	Protection *string `pulumi:"protection"`
	// The public key of the wrapping key.
	PublicKey *string `pulumi:"publicKey"`
	// The purpose for which the key will be used. Possible values are: `wrapSymmetricKey`, `wrapAsymmetricKey`.
	Purpose *string `pulumi:"purpose"`
	// The resource region. If not defined, the provider region is used.
	Region *string `pulumi:"region"`
	// The ID of the wrapping key
	WrappingKeyId *string `pulumi:"wrappingKeyId"`
}

type KmsWrappingKeyState struct {
	// The access scope of the key. Default is `PUBLIC`. Possible values are: `PUBLIC`, `SNA`.
	AccessScope pulumi.StringPtrInput
	// The wrapping algorithm used to wrap the key to import. Possible values are: `rsa2048OaepSha256`, `rsa3072OaepSha256`, `rsa4096OaepSha256`, `rsa4096OaepSha512`, `rsa2048OaepSha256Aes256KeyWrap`, `rsa3072OaepSha256Aes256KeyWrap`, `rsa4096OaepSha256Aes256KeyWrap`, `rsa4096OaepSha512Aes256KeyWrap`.
	Algorithm pulumi.StringPtrInput
	// The date and time the creation of the wrapping key was triggered.
	CreatedAt pulumi.StringPtrInput
	// A user chosen description to distinguish multiple wrapping keys.
	Description pulumi.StringPtrInput
	// The display name to distinguish multiple wrapping keys.
	DisplayName pulumi.StringPtrInput
	// The date and time the wrapping key will expire.
	ExpiresAt pulumi.StringPtrInput
	// The ID of the associated keyring
	KeyringId pulumi.StringPtrInput
	// STACKIT project ID to which the keyring is associated.
	ProjectId pulumi.StringPtrInput
	// The underlying system that is responsible for protecting the key material. Possible values are: `software`.
	Protection pulumi.StringPtrInput
	// The public key of the wrapping key.
	PublicKey pulumi.StringPtrInput
	// The purpose for which the key will be used. Possible values are: `wrapSymmetricKey`, `wrapAsymmetricKey`.
	Purpose pulumi.StringPtrInput
	// The resource region. If not defined, the provider region is used.
	Region pulumi.StringPtrInput
	// The ID of the wrapping key
	WrappingKeyId pulumi.StringPtrInput
}

func (KmsWrappingKeyState) ElementType() reflect.Type {
	return reflect.TypeOf((*kmsWrappingKeyState)(nil)).Elem()
}

type kmsWrappingKeyArgs struct {
	// The access scope of the key. Default is `PUBLIC`. Possible values are: `PUBLIC`, `SNA`.
	AccessScope *string `pulumi:"accessScope"`
	// The wrapping algorithm used to wrap the key to import. Possible values are: `rsa2048OaepSha256`, `rsa3072OaepSha256`, `rsa4096OaepSha256`, `rsa4096OaepSha512`, `rsa2048OaepSha256Aes256KeyWrap`, `rsa3072OaepSha256Aes256KeyWrap`, `rsa4096OaepSha256Aes256KeyWrap`, `rsa4096OaepSha512Aes256KeyWrap`.
	Algorithm string `pulumi:"algorithm"`
	// A user chosen description to distinguish multiple wrapping keys.
	Description *string `pulumi:"description"`
	// The display name to distinguish multiple wrapping keys.
	DisplayName string `pulumi:"displayName"`
	// The ID of the associated keyring
	KeyringId string `pulumi:"keyringId"`
	// STACKIT project ID to which the keyring is associated.
	ProjectId string `pulumi:"projectId"`
	// The underlying system that is responsible for protecting the key material. Possible values are: `software`.
	Protection string `pulumi:"protection"`
	// The purpose for which the key will be used. Possible values are: `wrapSymmetricKey`, `wrapAsymmetricKey`.
	Purpose string `pulumi:"purpose"`
	// The resource region. If not defined, the provider region is used.
	Region *string `pulumi:"region"`
}

// The set of arguments for constructing a KmsWrappingKey resource.
type KmsWrappingKeyArgs struct {
	// The access scope of the key. Default is `PUBLIC`. Possible values are: `PUBLIC`, `SNA`.
	AccessScope pulumi.StringPtrInput
	// The wrapping algorithm used to wrap the key to import. Possible values are: `rsa2048OaepSha256`, `rsa3072OaepSha256`, `rsa4096OaepSha256`, `rsa4096OaepSha512`, `rsa2048OaepSha256Aes256KeyWrap`, `rsa3072OaepSha256Aes256KeyWrap`, `rsa4096OaepSha256Aes256KeyWrap`, `rsa4096OaepSha512Aes256KeyWrap`.
	Algorithm pulumi.StringInput
	// A user chosen description to distinguish multiple wrapping keys.
	Description pulumi.StringPtrInput
	// The display name to distinguish multiple wrapping keys.
	DisplayName pulumi.StringInput
	// The ID of the associated keyring
	KeyringId pulumi.StringInput
	// STACKIT project ID to which the keyring is associated.
	ProjectId pulumi.StringInput
	// The underlying system that is responsible for protecting the key material. Possible values are: `software`.
	Protection pulumi.StringInput
	// The purpose for which the key will be used. Possible values are: `wrapSymmetricKey`, `wrapAsymmetricKey`.
	Purpose pulumi.StringInput
	// The resource region. If not defined, the provider region is used.
	Region pulumi.StringPtrInput
}

func (KmsWrappingKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kmsWrappingKeyArgs)(nil)).Elem()
}

type KmsWrappingKeyInput interface {
	pulumi.Input

	ToKmsWrappingKeyOutput() KmsWrappingKeyOutput
	ToKmsWrappingKeyOutputWithContext(ctx context.Context) KmsWrappingKeyOutput
}

func (*KmsWrappingKey) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsWrappingKey)(nil)).Elem()
}

func (i *KmsWrappingKey) ToKmsWrappingKeyOutput() KmsWrappingKeyOutput {
	return i.ToKmsWrappingKeyOutputWithContext(context.Background())
}

func (i *KmsWrappingKey) ToKmsWrappingKeyOutputWithContext(ctx context.Context) KmsWrappingKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsWrappingKeyOutput)
}

// KmsWrappingKeyArrayInput is an input type that accepts KmsWrappingKeyArray and KmsWrappingKeyArrayOutput values.
// You can construct a concrete instance of `KmsWrappingKeyArrayInput` via:
//
//	KmsWrappingKeyArray{ KmsWrappingKeyArgs{...} }
type KmsWrappingKeyArrayInput interface {
	pulumi.Input

	ToKmsWrappingKeyArrayOutput() KmsWrappingKeyArrayOutput
	ToKmsWrappingKeyArrayOutputWithContext(context.Context) KmsWrappingKeyArrayOutput
}

type KmsWrappingKeyArray []KmsWrappingKeyInput

func (KmsWrappingKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KmsWrappingKey)(nil)).Elem()
}

func (i KmsWrappingKeyArray) ToKmsWrappingKeyArrayOutput() KmsWrappingKeyArrayOutput {
	return i.ToKmsWrappingKeyArrayOutputWithContext(context.Background())
}

func (i KmsWrappingKeyArray) ToKmsWrappingKeyArrayOutputWithContext(ctx context.Context) KmsWrappingKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsWrappingKeyArrayOutput)
}

// KmsWrappingKeyMapInput is an input type that accepts KmsWrappingKeyMap and KmsWrappingKeyMapOutput values.
// You can construct a concrete instance of `KmsWrappingKeyMapInput` via:
//
//	KmsWrappingKeyMap{ "key": KmsWrappingKeyArgs{...} }
type KmsWrappingKeyMapInput interface {
	pulumi.Input

	ToKmsWrappingKeyMapOutput() KmsWrappingKeyMapOutput
	ToKmsWrappingKeyMapOutputWithContext(context.Context) KmsWrappingKeyMapOutput
}

type KmsWrappingKeyMap map[string]KmsWrappingKeyInput

func (KmsWrappingKeyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KmsWrappingKey)(nil)).Elem()
}

func (i KmsWrappingKeyMap) ToKmsWrappingKeyMapOutput() KmsWrappingKeyMapOutput {
	return i.ToKmsWrappingKeyMapOutputWithContext(context.Background())
}

func (i KmsWrappingKeyMap) ToKmsWrappingKeyMapOutputWithContext(ctx context.Context) KmsWrappingKeyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KmsWrappingKeyMapOutput)
}

type KmsWrappingKeyOutput struct{ *pulumi.OutputState }

func (KmsWrappingKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KmsWrappingKey)(nil)).Elem()
}

func (o KmsWrappingKeyOutput) ToKmsWrappingKeyOutput() KmsWrappingKeyOutput {
	return o
}

func (o KmsWrappingKeyOutput) ToKmsWrappingKeyOutputWithContext(ctx context.Context) KmsWrappingKeyOutput {
	return o
}

// The access scope of the key. Default is `PUBLIC`. Possible values are: `PUBLIC`, `SNA`.
func (o KmsWrappingKeyOutput) AccessScope() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsWrappingKey) pulumi.StringOutput { return v.AccessScope }).(pulumi.StringOutput)
}

// The wrapping algorithm used to wrap the key to import. Possible values are: `rsa2048OaepSha256`, `rsa3072OaepSha256`, `rsa4096OaepSha256`, `rsa4096OaepSha512`, `rsa2048OaepSha256Aes256KeyWrap`, `rsa3072OaepSha256Aes256KeyWrap`, `rsa4096OaepSha256Aes256KeyWrap`, `rsa4096OaepSha512Aes256KeyWrap`.
func (o KmsWrappingKeyOutput) Algorithm() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsWrappingKey) pulumi.StringOutput { return v.Algorithm }).(pulumi.StringOutput)
}

// The date and time the creation of the wrapping key was triggered.
func (o KmsWrappingKeyOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsWrappingKey) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// A user chosen description to distinguish multiple wrapping keys.
func (o KmsWrappingKeyOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *KmsWrappingKey) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The display name to distinguish multiple wrapping keys.
func (o KmsWrappingKeyOutput) DisplayName() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsWrappingKey) pulumi.StringOutput { return v.DisplayName }).(pulumi.StringOutput)
}

// The date and time the wrapping key will expire.
func (o KmsWrappingKeyOutput) ExpiresAt() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsWrappingKey) pulumi.StringOutput { return v.ExpiresAt }).(pulumi.StringOutput)
}

// The ID of the associated keyring
func (o KmsWrappingKeyOutput) KeyringId() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsWrappingKey) pulumi.StringOutput { return v.KeyringId }).(pulumi.StringOutput)
}

// STACKIT project ID to which the keyring is associated.
func (o KmsWrappingKeyOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsWrappingKey) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// The underlying system that is responsible for protecting the key material. Possible values are: `software`.
func (o KmsWrappingKeyOutput) Protection() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsWrappingKey) pulumi.StringOutput { return v.Protection }).(pulumi.StringOutput)
}

// The public key of the wrapping key.
func (o KmsWrappingKeyOutput) PublicKey() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsWrappingKey) pulumi.StringOutput { return v.PublicKey }).(pulumi.StringOutput)
}

// The purpose for which the key will be used. Possible values are: `wrapSymmetricKey`, `wrapAsymmetricKey`.
func (o KmsWrappingKeyOutput) Purpose() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsWrappingKey) pulumi.StringOutput { return v.Purpose }).(pulumi.StringOutput)
}

// The resource region. If not defined, the provider region is used.
func (o KmsWrappingKeyOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsWrappingKey) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// The ID of the wrapping key
func (o KmsWrappingKeyOutput) WrappingKeyId() pulumi.StringOutput {
	return o.ApplyT(func(v *KmsWrappingKey) pulumi.StringOutput { return v.WrappingKeyId }).(pulumi.StringOutput)
}

type KmsWrappingKeyArrayOutput struct{ *pulumi.OutputState }

func (KmsWrappingKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KmsWrappingKey)(nil)).Elem()
}

func (o KmsWrappingKeyArrayOutput) ToKmsWrappingKeyArrayOutput() KmsWrappingKeyArrayOutput {
	return o
}

func (o KmsWrappingKeyArrayOutput) ToKmsWrappingKeyArrayOutputWithContext(ctx context.Context) KmsWrappingKeyArrayOutput {
	return o
}

func (o KmsWrappingKeyArrayOutput) Index(i pulumi.IntInput) KmsWrappingKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *KmsWrappingKey {
		return vs[0].([]*KmsWrappingKey)[vs[1].(int)]
	}).(KmsWrappingKeyOutput)
}

type KmsWrappingKeyMapOutput struct{ *pulumi.OutputState }

func (KmsWrappingKeyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KmsWrappingKey)(nil)).Elem()
}

func (o KmsWrappingKeyMapOutput) ToKmsWrappingKeyMapOutput() KmsWrappingKeyMapOutput {
	return o
}

func (o KmsWrappingKeyMapOutput) ToKmsWrappingKeyMapOutputWithContext(ctx context.Context) KmsWrappingKeyMapOutput {
	return o
}

func (o KmsWrappingKeyMapOutput) MapIndex(k pulumi.StringInput) KmsWrappingKeyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *KmsWrappingKey {
		return vs[0].(map[string]*KmsWrappingKey)[vs[1].(string)]
	}).(KmsWrappingKeyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KmsWrappingKeyInput)(nil)).Elem(), &KmsWrappingKey{})
	pulumi.RegisterInputType(reflect.TypeOf((*KmsWrappingKeyArrayInput)(nil)).Elem(), KmsWrappingKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KmsWrappingKeyMapInput)(nil)).Elem(), KmsWrappingKeyMap{})
	pulumi.RegisterOutputType(KmsWrappingKeyOutput{})
	pulumi.RegisterOutputType(KmsWrappingKeyArrayOutput{})
	pulumi.RegisterOutputType(KmsWrappingKeyMapOutput{})
}
