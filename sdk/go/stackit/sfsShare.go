// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package stackit

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/stackitcloud/pulumi-stackit/sdk/go/stackit/internal"
)

// SFS Share schema. Must have a `region` specified in the provider configuration.
//
// > This resource is in beta and may be subject to breaking changes in the future. Use with caution. See our guide for how to opt-in to use beta resources.
//
// ## Example Usage
type SfsShare struct {
	pulumi.CustomResourceState

	// Name of the Share Export Policy to use in the Share.
	// Note that if this is set to an empty string, the Share can only be mounted in read only by
	// clients with IPs matching the IP ACL of the Resource Pool hosting this Share.
	// You can also assign a Share Export Policy after creating the Share
	ExportPolicy pulumi.StringOutput `pulumi:"exportPolicy"`
	// Mount path of the Share, used to mount the Share
	MountPath pulumi.StringOutput `pulumi:"mountPath"`
	// Name of the share.
	Name pulumi.StringOutput `pulumi:"name"`
	// STACKIT project ID to which the share is associated.
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// The resource region. If not defined, the provider region is used.
	Region pulumi.StringOutput `pulumi:"region"`
	// The ID of the resource pool for the SFS share.
	ResourcePoolId pulumi.StringOutput `pulumi:"resourcePoolId"`
	// share ID
	ShareId pulumi.StringOutput `pulumi:"shareId"`
	// Space hard limit for the Share.
	// 			If zero, the Share will have access to the full space of the Resource Pool it lives in.
	// 			(unit: gigabytes)
	SpaceHardLimitGigabytes pulumi.IntOutput `pulumi:"spaceHardLimitGigabytes"`
}

// NewSfsShare registers a new resource with the given unique name, arguments, and options.
func NewSfsShare(ctx *pulumi.Context,
	name string, args *SfsShareArgs, opts ...pulumi.ResourceOption) (*SfsShare, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ExportPolicy == nil {
		return nil, errors.New("invalid value for required argument 'ExportPolicy'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	if args.ResourcePoolId == nil {
		return nil, errors.New("invalid value for required argument 'ResourcePoolId'")
	}
	if args.SpaceHardLimitGigabytes == nil {
		return nil, errors.New("invalid value for required argument 'SpaceHardLimitGigabytes'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SfsShare
	err := ctx.RegisterResource("stackit:index/sfsShare:SfsShare", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSfsShare gets an existing SfsShare resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSfsShare(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SfsShareState, opts ...pulumi.ResourceOption) (*SfsShare, error) {
	var resource SfsShare
	err := ctx.ReadResource("stackit:index/sfsShare:SfsShare", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SfsShare resources.
type sfsShareState struct {
	// Name of the Share Export Policy to use in the Share.
	// Note that if this is set to an empty string, the Share can only be mounted in read only by
	// clients with IPs matching the IP ACL of the Resource Pool hosting this Share.
	// You can also assign a Share Export Policy after creating the Share
	ExportPolicy *string `pulumi:"exportPolicy"`
	// Mount path of the Share, used to mount the Share
	MountPath *string `pulumi:"mountPath"`
	// Name of the share.
	Name *string `pulumi:"name"`
	// STACKIT project ID to which the share is associated.
	ProjectId *string `pulumi:"projectId"`
	// The resource region. If not defined, the provider region is used.
	Region *string `pulumi:"region"`
	// The ID of the resource pool for the SFS share.
	ResourcePoolId *string `pulumi:"resourcePoolId"`
	// share ID
	ShareId *string `pulumi:"shareId"`
	// Space hard limit for the Share.
	// 			If zero, the Share will have access to the full space of the Resource Pool it lives in.
	// 			(unit: gigabytes)
	SpaceHardLimitGigabytes *int `pulumi:"spaceHardLimitGigabytes"`
}

type SfsShareState struct {
	// Name of the Share Export Policy to use in the Share.
	// Note that if this is set to an empty string, the Share can only be mounted in read only by
	// clients with IPs matching the IP ACL of the Resource Pool hosting this Share.
	// You can also assign a Share Export Policy after creating the Share
	ExportPolicy pulumi.StringPtrInput
	// Mount path of the Share, used to mount the Share
	MountPath pulumi.StringPtrInput
	// Name of the share.
	Name pulumi.StringPtrInput
	// STACKIT project ID to which the share is associated.
	ProjectId pulumi.StringPtrInput
	// The resource region. If not defined, the provider region is used.
	Region pulumi.StringPtrInput
	// The ID of the resource pool for the SFS share.
	ResourcePoolId pulumi.StringPtrInput
	// share ID
	ShareId pulumi.StringPtrInput
	// Space hard limit for the Share.
	// 			If zero, the Share will have access to the full space of the Resource Pool it lives in.
	// 			(unit: gigabytes)
	SpaceHardLimitGigabytes pulumi.IntPtrInput
}

func (SfsShareState) ElementType() reflect.Type {
	return reflect.TypeOf((*sfsShareState)(nil)).Elem()
}

type sfsShareArgs struct {
	// Name of the Share Export Policy to use in the Share.
	// Note that if this is set to an empty string, the Share can only be mounted in read only by
	// clients with IPs matching the IP ACL of the Resource Pool hosting this Share.
	// You can also assign a Share Export Policy after creating the Share
	ExportPolicy string `pulumi:"exportPolicy"`
	// Name of the share.
	Name *string `pulumi:"name"`
	// STACKIT project ID to which the share is associated.
	ProjectId string `pulumi:"projectId"`
	// The resource region. If not defined, the provider region is used.
	Region *string `pulumi:"region"`
	// The ID of the resource pool for the SFS share.
	ResourcePoolId string `pulumi:"resourcePoolId"`
	// Space hard limit for the Share.
	// 			If zero, the Share will have access to the full space of the Resource Pool it lives in.
	// 			(unit: gigabytes)
	SpaceHardLimitGigabytes int `pulumi:"spaceHardLimitGigabytes"`
}

// The set of arguments for constructing a SfsShare resource.
type SfsShareArgs struct {
	// Name of the Share Export Policy to use in the Share.
	// Note that if this is set to an empty string, the Share can only be mounted in read only by
	// clients with IPs matching the IP ACL of the Resource Pool hosting this Share.
	// You can also assign a Share Export Policy after creating the Share
	ExportPolicy pulumi.StringInput
	// Name of the share.
	Name pulumi.StringPtrInput
	// STACKIT project ID to which the share is associated.
	ProjectId pulumi.StringInput
	// The resource region. If not defined, the provider region is used.
	Region pulumi.StringPtrInput
	// The ID of the resource pool for the SFS share.
	ResourcePoolId pulumi.StringInput
	// Space hard limit for the Share.
	// 			If zero, the Share will have access to the full space of the Resource Pool it lives in.
	// 			(unit: gigabytes)
	SpaceHardLimitGigabytes pulumi.IntInput
}

func (SfsShareArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sfsShareArgs)(nil)).Elem()
}

type SfsShareInput interface {
	pulumi.Input

	ToSfsShareOutput() SfsShareOutput
	ToSfsShareOutputWithContext(ctx context.Context) SfsShareOutput
}

func (*SfsShare) ElementType() reflect.Type {
	return reflect.TypeOf((**SfsShare)(nil)).Elem()
}

func (i *SfsShare) ToSfsShareOutput() SfsShareOutput {
	return i.ToSfsShareOutputWithContext(context.Background())
}

func (i *SfsShare) ToSfsShareOutputWithContext(ctx context.Context) SfsShareOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SfsShareOutput)
}

// SfsShareArrayInput is an input type that accepts SfsShareArray and SfsShareArrayOutput values.
// You can construct a concrete instance of `SfsShareArrayInput` via:
//
//	SfsShareArray{ SfsShareArgs{...} }
type SfsShareArrayInput interface {
	pulumi.Input

	ToSfsShareArrayOutput() SfsShareArrayOutput
	ToSfsShareArrayOutputWithContext(context.Context) SfsShareArrayOutput
}

type SfsShareArray []SfsShareInput

func (SfsShareArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SfsShare)(nil)).Elem()
}

func (i SfsShareArray) ToSfsShareArrayOutput() SfsShareArrayOutput {
	return i.ToSfsShareArrayOutputWithContext(context.Background())
}

func (i SfsShareArray) ToSfsShareArrayOutputWithContext(ctx context.Context) SfsShareArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SfsShareArrayOutput)
}

// SfsShareMapInput is an input type that accepts SfsShareMap and SfsShareMapOutput values.
// You can construct a concrete instance of `SfsShareMapInput` via:
//
//	SfsShareMap{ "key": SfsShareArgs{...} }
type SfsShareMapInput interface {
	pulumi.Input

	ToSfsShareMapOutput() SfsShareMapOutput
	ToSfsShareMapOutputWithContext(context.Context) SfsShareMapOutput
}

type SfsShareMap map[string]SfsShareInput

func (SfsShareMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SfsShare)(nil)).Elem()
}

func (i SfsShareMap) ToSfsShareMapOutput() SfsShareMapOutput {
	return i.ToSfsShareMapOutputWithContext(context.Background())
}

func (i SfsShareMap) ToSfsShareMapOutputWithContext(ctx context.Context) SfsShareMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SfsShareMapOutput)
}

type SfsShareOutput struct{ *pulumi.OutputState }

func (SfsShareOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SfsShare)(nil)).Elem()
}

func (o SfsShareOutput) ToSfsShareOutput() SfsShareOutput {
	return o
}

func (o SfsShareOutput) ToSfsShareOutputWithContext(ctx context.Context) SfsShareOutput {
	return o
}

// Name of the Share Export Policy to use in the Share.
// Note that if this is set to an empty string, the Share can only be mounted in read only by
// clients with IPs matching the IP ACL of the Resource Pool hosting this Share.
// You can also assign a Share Export Policy after creating the Share
func (o SfsShareOutput) ExportPolicy() pulumi.StringOutput {
	return o.ApplyT(func(v *SfsShare) pulumi.StringOutput { return v.ExportPolicy }).(pulumi.StringOutput)
}

// Mount path of the Share, used to mount the Share
func (o SfsShareOutput) MountPath() pulumi.StringOutput {
	return o.ApplyT(func(v *SfsShare) pulumi.StringOutput { return v.MountPath }).(pulumi.StringOutput)
}

// Name of the share.
func (o SfsShareOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SfsShare) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// STACKIT project ID to which the share is associated.
func (o SfsShareOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *SfsShare) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// The resource region. If not defined, the provider region is used.
func (o SfsShareOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *SfsShare) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// The ID of the resource pool for the SFS share.
func (o SfsShareOutput) ResourcePoolId() pulumi.StringOutput {
	return o.ApplyT(func(v *SfsShare) pulumi.StringOutput { return v.ResourcePoolId }).(pulumi.StringOutput)
}

// share ID
func (o SfsShareOutput) ShareId() pulumi.StringOutput {
	return o.ApplyT(func(v *SfsShare) pulumi.StringOutput { return v.ShareId }).(pulumi.StringOutput)
}

// Space hard limit for the Share.
//
//	If zero, the Share will have access to the full space of the Resource Pool it lives in.
//	(unit: gigabytes)
func (o SfsShareOutput) SpaceHardLimitGigabytes() pulumi.IntOutput {
	return o.ApplyT(func(v *SfsShare) pulumi.IntOutput { return v.SpaceHardLimitGigabytes }).(pulumi.IntOutput)
}

type SfsShareArrayOutput struct{ *pulumi.OutputState }

func (SfsShareArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SfsShare)(nil)).Elem()
}

func (o SfsShareArrayOutput) ToSfsShareArrayOutput() SfsShareArrayOutput {
	return o
}

func (o SfsShareArrayOutput) ToSfsShareArrayOutputWithContext(ctx context.Context) SfsShareArrayOutput {
	return o
}

func (o SfsShareArrayOutput) Index(i pulumi.IntInput) SfsShareOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SfsShare {
		return vs[0].([]*SfsShare)[vs[1].(int)]
	}).(SfsShareOutput)
}

type SfsShareMapOutput struct{ *pulumi.OutputState }

func (SfsShareMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SfsShare)(nil)).Elem()
}

func (o SfsShareMapOutput) ToSfsShareMapOutput() SfsShareMapOutput {
	return o
}

func (o SfsShareMapOutput) ToSfsShareMapOutputWithContext(ctx context.Context) SfsShareMapOutput {
	return o
}

func (o SfsShareMapOutput) MapIndex(k pulumi.StringInput) SfsShareOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SfsShare {
		return vs[0].(map[string]*SfsShare)[vs[1].(string)]
	}).(SfsShareOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SfsShareInput)(nil)).Elem(), &SfsShare{})
	pulumi.RegisterInputType(reflect.TypeOf((*SfsShareArrayInput)(nil)).Elem(), SfsShareArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SfsShareMapInput)(nil)).Elem(), SfsShareMap{})
	pulumi.RegisterOutputType(SfsShareOutput{})
	pulumi.RegisterOutputType(SfsShareArrayOutput{})
	pulumi.RegisterOutputType(SfsShareMapOutput{})
}
