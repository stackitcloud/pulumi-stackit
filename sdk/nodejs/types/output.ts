// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CdnCustomDomainCertificate {
    /**
     * The PEM-encoded TLS certificate. Required for custom certificates.
     */
    certificate?: string;
    /**
     * The PEM-encoded private key for the certificate. Required for custom certificates. The certificate will be updated if this field is changed.
     */
    privateKey?: string;
    /**
     * A version identifier for the certificate. Required for custom certificates. The certificate will be updated if this field is changed.
     */
    version: number;
}

export interface CdnDistributionConfig {
    /**
     * The configured backend for the distribution
     */
    backend: outputs.CdnDistributionConfigBackend;
    /**
     * The configured countries where distribution of content is blocked
     */
    blockedCountries?: string[];
    /**
     * Configuration for the Image Optimizer. This is a paid feature that automatically optimizes images to reduce their file size for faster delivery, leading to improved website performance and a better user experience.
     */
    optimizer: outputs.CdnDistributionConfigOptimizer;
    /**
     * The configured regions where content will be hosted
     */
    regions: string[];
}

export interface CdnDistributionConfigBackend {
    /**
     * A map of URLs to a list of countries where content is allowed.
     */
    geofencing?: {[key: string]: string[]};
    /**
     * The configured origin request headers for the backend
     */
    originRequestHeaders?: {[key: string]: string};
    /**
     * The configured backend type for the distribution
     */
    originUrl: string;
    /**
     * The configured backend type. Possible values are: `http`.
     */
    type: string;
}

export interface CdnDistributionConfigOptimizer {
    enabled: boolean;
}

export interface CdnDistributionDomain {
    /**
     * List of domain errors
     */
    errors: string[];
    /**
     * The name of the domain
     */
    name: string;
    /**
     * The status of the domain
     */
    status: string;
    /**
     * The type of the domain. Each distribution has one domain of type "managed", and domains of type "custom" may be additionally created by the user
     */
    type: string;
}

export interface GetCdnCustomDomainCertificate {
    /**
     * A version identifier for the certificate. Required for custom certificates. The certificate will be updated if this field is changed.
     */
    version: number;
}

export interface GetCdnDistributionConfig {
    /**
     * The configured backend for the distribution
     */
    backend: outputs.GetCdnDistributionConfigBackend;
    /**
     * The configured countries where distribution of content is blocked
     */
    blockedCountries?: string[];
    /**
     * Configuration for the Image Optimizer. This is a paid feature that automatically optimizes images to reduce their file size for faster delivery, leading to improved website performance and a better user experience.
     */
    optimizer: outputs.GetCdnDistributionConfigOptimizer;
    /**
     * The configured regions where content will be hosted
     */
    regions: string[];
}

export interface GetCdnDistributionConfigBackend {
    /**
     * A map of URLs to a list of countries where content is allowed.
     */
    geofencing: {[key: string]: string[]};
    /**
     * The configured origin request headers for the backend
     */
    originRequestHeaders: {[key: string]: string};
    /**
     * The configured backend type for the distribution
     */
    originUrl: string;
    /**
     * The configured backend type. Possible values are: `http`.
     */
    type: string;
}

export interface GetCdnDistributionConfigOptimizer {
    enabled: boolean;
}

export interface GetCdnDistributionDomain {
    /**
     * List of domain errors
     */
    errors: string[];
    /**
     * The name of the domain
     */
    name: string;
    /**
     * The status of the domain
     */
    status: string;
    /**
     * The type of the domain. Each distribution has one domain of type "managed", and domains of type "custom" may be additionally created by the user
     */
    type: string;
}

export interface GetEdgecloudInstancesInstance {
    /**
     * The date and time the instance was created.
     */
    created: string;
    /**
     * Description of the instance.
     */
    description: string;
    /**
     * The display name of the instance.
     */
    displayName: string;
    /**
     * Frontend URL for the Edge Cloud instance.
     */
    frontendUrl: string;
    /**
     * The ID of the instance.
     */
    instanceId: string;
    /**
     * The plan ID for the instance.
     */
    planId: string;
    /**
     * The region where the instance is located.
     */
    region: string;
    /**
     * The status of the instance.
     */
    status: string;
}

export interface GetEdgecloudPlansPlan {
    /**
     * Description of the plan.
     */
    description: string;
    /**
     * The ID of the plan.
     */
    id: string;
    /**
     * Maximum number of Edge Cloud hosts that can be used.
     */
    maxEdgeHosts: number;
    /**
     * The name of the plan.
     */
    name: string;
}

export interface GetImageChecksum {
    /**
     * Algorithm for the checksum of the image data.
     */
    algorithm: string;
    /**
     * Hexdigest of the checksum of the image data.
     */
    digest: string;
}

export interface GetImageConfig {
    /**
     * Enables the BIOS bootmenu.
     */
    bootMenu: boolean;
    /**
     * Sets CDROM bus controller type.
     */
    cdromBus: string;
    /**
     * Sets Disk bus controller type.
     */
    diskBus: string;
    /**
     * Sets virtual network interface model.
     */
    nicModel: string;
    /**
     * Enables operating system specific optimizations.
     */
    operatingSystem: string;
    /**
     * Operating system distribution.
     */
    operatingSystemDistro: string;
    /**
     * Version of the operating system.
     */
    operatingSystemVersion: string;
    /**
     * Sets the device bus when the image is used as a rescue image.
     */
    rescueBus: string;
    /**
     * Sets the device when the image is used as a rescue image.
     */
    rescueDevice: string;
    /**
     * Enables Secure Boot.
     */
    secureBoot: boolean;
    /**
     * Enables UEFI boot.
     */
    uefi: boolean;
    /**
     * Sets Graphic device model.
     */
    videoModel: string;
    /**
     * Enables the use of VirtIO SCSI to provide block device access. By default instances use VirtIO Block.
     */
    virtioScsi: boolean;
}

export interface GetImageV2Checksum {
    /**
     * Algorithm for the checksum of the image data.
     */
    algorithm: string;
    /**
     * Hexdigest of the checksum of the image data.
     */
    digest: string;
}

export interface GetImageV2Config {
    /**
     * Enables the BIOS bootmenu.
     */
    bootMenu: boolean;
    /**
     * Sets CDROM bus controller type.
     */
    cdromBus: string;
    /**
     * Sets Disk bus controller type.
     */
    diskBus: string;
    /**
     * Sets virtual network interface model.
     */
    nicModel: string;
    /**
     * Enables operating system specific optimizations.
     */
    operatingSystem: string;
    /**
     * Operating system distribution.
     */
    operatingSystemDistro: string;
    /**
     * Version of the operating system.
     */
    operatingSystemVersion: string;
    /**
     * Sets the device bus when the image is used as a rescue image.
     */
    rescueBus: string;
    /**
     * Sets the device when the image is used as a rescue image.
     */
    rescueDevice: string;
    /**
     * Enables Secure Boot.
     */
    secureBoot: boolean;
    /**
     * Enables UEFI boot.
     */
    uefi: boolean;
    /**
     * Sets Graphic device model.
     */
    videoModel: string;
    /**
     * Enables the use of VirtIO SCSI to provide block device access. By default instances use VirtIO Block.
     */
    virtioScsi: boolean;
}

export interface GetImageV2Filter {
    /**
     * Filter images by operating system distribution. For example: `ubuntu`, `ubuntu-arm64`, `debian`, `rhel`, etc.
     */
    distro?: string;
    /**
     * Filter images by operating system type, such as `linux` or `windows`.
     */
    os?: string;
    /**
     * Filter images with Secure Boot support. Set to `true` to match images that support Secure Boot.
     */
    secureBoot?: boolean;
    /**
     * Filter images based on UEFI support. Set to `true` to match images that support UEFI.
     */
    uefi?: boolean;
    /**
     * Filter images by OS distribution version, such as `22.04`, `11`, or `9.1`.
     */
    version?: string;
}

export interface GetLoadbalancerListener {
    displayName: string;
    /**
     * Port number where we listen for traffic.
     */
    port: number;
    /**
     * Protocol is the highest network protocol we understand to load balance.
     */
    protocol: string;
    /**
     * A list of domain names to match in order to pass TLS traffic to the target pool in the current listener
     */
    serverNameIndicators?: outputs.GetLoadbalancerListenerServerNameIndicator[];
    /**
     * Reference target pool by target pool name.
     */
    targetPool: string;
    /**
     * Options that are specific to the TCP protocol.
     */
    tcp: outputs.GetLoadbalancerListenerTcp;
    /**
     * Options that are specific to the UDP protocol.
     */
    udp: outputs.GetLoadbalancerListenerUdp;
}

export interface GetLoadbalancerListenerServerNameIndicator {
    /**
     * A domain name to match in order to pass TLS traffic to the target pool in the current listener
     */
    name?: string;
}

export interface GetLoadbalancerListenerTcp {
    /**
     * Time after which an idle connection is closed. The default value is set to 5 minutes, and the maximum value is one hour.
     */
    idleTimeout: string;
}

export interface GetLoadbalancerListenerUdp {
    /**
     * Time after which an idle session is closed. The default value is set to 1 minute, and the maximum value is 2 minutes.
     */
    idleTimeout: string;
}

export interface GetLoadbalancerNetwork {
    /**
     * Openstack network ID.
     */
    networkId: string;
    /**
     * The role defines how the load balancer is using the network.
     */
    role: string;
}

export interface GetLoadbalancerOptions {
    /**
     * Load Balancer is accessible only from an IP address in this range.
     */
    acls: string[];
    /**
     * We offer Load Balancer metrics observability via ARGUS or external solutions.
     */
    observability: outputs.GetLoadbalancerOptionsObservability;
    /**
     * If true, Load Balancer is accessible only via a private network IP address.
     */
    privateNetworkOnly: boolean;
}

export interface GetLoadbalancerOptionsObservability {
    /**
     * Observability logs configuration.
     */
    logs: outputs.GetLoadbalancerOptionsObservabilityLogs;
    /**
     * Observability metrics configuration.
     */
    metrics: outputs.GetLoadbalancerOptionsObservabilityMetrics;
}

export interface GetLoadbalancerOptionsObservabilityLogs {
    /**
     * Credentials reference for logs.
     */
    credentialsRef: string;
    /**
     * Credentials reference for logs.
     */
    pushUrl: string;
}

export interface GetLoadbalancerOptionsObservabilityMetrics {
    /**
     * Credentials reference for metrics.
     */
    credentialsRef: string;
    /**
     * Credentials reference for metrics.
     */
    pushUrl: string;
}

export interface GetLoadbalancerTargetPool {
    activeHealthCheck: outputs.GetLoadbalancerTargetPoolActiveHealthCheck;
    /**
     * Target pool name.
     */
    name: string;
    /**
     * Here you can setup various session persistence options, so far only "`useSourceIpAddress`" is supported.
     */
    sessionPersistence?: outputs.GetLoadbalancerTargetPoolSessionPersistence;
    /**
     * Identical port number where each target listens for traffic.
     */
    targetPort: number;
    /**
     * List of all targets which will be used in the pool. Limited to 1000.
     */
    targets: outputs.GetLoadbalancerTargetPoolTarget[];
}

export interface GetLoadbalancerTargetPoolActiveHealthCheck {
    /**
     * Healthy threshold of the health checking.
     */
    healthyThreshold: number;
    /**
     * Interval duration of health checking in seconds.
     */
    interval: string;
    /**
     * Interval duration threshold of the health checking in seconds.
     */
    intervalJitter: string;
    /**
     * Active health checking timeout duration in seconds.
     */
    timeout: string;
    /**
     * Unhealthy threshold of the health checking.
     */
    unhealthyThreshold: number;
}

export interface GetLoadbalancerTargetPoolSessionPersistence {
    /**
     * If true then all connections from one source IP address are redirected to the same target. This setting changes the load balancing algorithm to Maglev.
     */
    useSourceIpAddress?: boolean;
}

export interface GetLoadbalancerTargetPoolTarget {
    /**
     * Target display name
     */
    displayName: string;
    /**
     * Target IP
     */
    ip: string;
}

export interface GetLogmeInstanceParameters {
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    fluentdTcp: number;
    fluentdTls: number;
    fluentdTlsCiphers: string;
    fluentdTlsMaxVersion: string;
    fluentdTlsMinVersion: string;
    fluentdTlsVersion: string;
    fluentdUdp: number;
    /**
     * If set, monitoring with Graphite will be enabled. Expects the host and port where the Graphite metrics should be sent to (host:port).
     */
    graphite: string;
    /**
     * Combination of an integer and a timerange when an index will be considered "old" and can be deleted. Possible values for the timerange are `s`, `m`, `h` and `d`.
     */
    ismDeletionAfter: string;
    ismJitter: number;
    /**
     * Jitter of the execution time.
     */
    ismJobInterval: number;
    /**
     * The amount of memory (in MB) allocated as heap by the JVM for OpenSearch.
     */
    javaHeapspace: number;
    /**
     * The amount of memory (in MB) used by the JVM to store metadata for OpenSearch.
     */
    javaMaxmetaspace: number;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted (in seconds).
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key.
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    opensearchTlsCiphers: string[];
    opensearchTlsProtocols: string[];
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
}

export interface GetMariadbInstanceParameters {
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    graphite: string;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted.
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
}

export interface GetMongodbflexInstanceFlavor {
    cpu: number;
    description: string;
    id: string;
    ram: number;
}

export interface GetMongodbflexInstanceOptions {
    /**
     * The number of days that daily backups will be retained.
     */
    dailySnapshotRetentionDays: number;
    /**
     * The number of months that monthly backups will be retained.
     */
    monthlySnapshotRetentionMonths: number;
    /**
     * The number of hours back in time the point-in-time recovery feature will be able to recover.
     */
    pointInTimeWindowHours: number;
    /**
     * The number of days that continuous backups (controlled via the `backupSchedule`) will be retained.
     */
    snapshotRetentionDays: number;
    /**
     * Type of the MongoDB Flex instance.
     */
    type: string;
    /**
     * The number of weeks that weekly backups will be retained.
     */
    weeklySnapshotRetentionWeeks: number;
}

export interface GetMongodbflexInstanceStorage {
    class: string;
    size: number;
}

export interface GetNetworkAreaNetworkRange {
    networkRangeId: string;
    prefix: string;
}

export interface GetNetworkAreaRegionIpv4 {
    /**
     * List of DNS Servers/Nameservers.
     */
    defaultNameservers: string[];
    /**
     * The default prefix length for networks in the network area.
     */
    defaultPrefixLength: number;
    /**
     * The maximal prefix length for networks in the network area.
     */
    maxPrefixLength: number;
    /**
     * The minimal prefix length for networks in the network area.
     */
    minPrefixLength: number;
    /**
     * List of Network ranges.
     */
    networkRanges: outputs.GetNetworkAreaRegionIpv4NetworkRange[];
    /**
     * IPv4 Classless Inter-Domain Routing (CIDR).
     */
    transferNetwork: string;
}

export interface GetNetworkAreaRegionIpv4NetworkRange {
    networkRangeId: string;
    /**
     * Classless Inter-Domain Routing (CIDR).
     */
    prefix: string;
}

export interface GetNetworkAreaRouteDestination {
    /**
     * CIDRV type. Possible values are: `cidrv4`, `cidrv6`.
     */
    type: string;
    /**
     * An CIDR string.
     */
    value: string;
}

export interface GetNetworkAreaRouteNextHop {
    /**
     * Type of the next hop. Possible values are: `blackhole`, `internet`, `ipv4`, `ipv6`.
     */
    type: string;
    /**
     * Either IPv4 or IPv6 (not set for blackhole and internet).
     */
    value: string;
}

export interface GetObservabilityAlertgroupRule {
    /**
     * The name of the alert rule. Is the identifier and must be unique in the group.
     */
    alert: string;
    /**
     * A map of key:value. Annotations to add or overwrite for each alert
     */
    annotations: {[key: string]: string};
    /**
     * The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and all resultant time series become pending/firing alerts.
     */
    expression: string;
    /**
     * Alerts are considered firing once they have been returned for this long. Alerts which have not yet fired for long enough are considered pending. Default is 0s
     */
    for: string;
    /**
     * A map of key:value. Labels to add or overwrite for each alert
     */
    labels: {[key: string]: string};
}

export interface GetObservabilityInstanceAlertConfig {
    /**
     * Global configuration for the alerts.
     */
    global: outputs.GetObservabilityInstanceAlertConfigGlobal;
    /**
     * List of alert receivers.
     */
    receivers: outputs.GetObservabilityInstanceAlertConfigReceiver[];
    /**
     * The route for the alert.
     */
    route: outputs.GetObservabilityInstanceAlertConfigRoute;
}

export interface GetObservabilityInstanceAlertConfigGlobal {
    /**
     * The API key for OpsGenie.
     */
    opsgenieApiKey: string;
    /**
     * The host to send OpsGenie API requests to. Must be a valid URL
     */
    opsgenieApiUrl: string;
    /**
     * The default value used by alertmanager if the alert does not include EndsAt. After this time passes, it can declare the alert as resolved if it has not been updated. This has no impact on alerts from Prometheus, as they always include EndsAt.
     */
    resolveTimeout: string;
    /**
     * SMTP authentication information. Must be a valid email address
     */
    smtpAuthIdentity: string;
    /**
     * SMTP Auth using LOGIN and PLAIN.
     */
    smtpAuthPassword: string;
    /**
     * SMTP Auth using CRAM-MD5, LOGIN and PLAIN. If empty, Alertmanager doesn't authenticate to the SMTP server.
     */
    smtpAuthUsername: string;
    /**
     * The default SMTP From header field. Must be a valid email address
     */
    smtpFrom: string;
    /**
     * The default SMTP smarthost used for sending emails, including port number. Port number usually is 25, or 587 for SMTP over TLS (sometimes referred to as STARTTLS).
     */
    smtpSmartHost: string;
}

export interface GetObservabilityInstanceAlertConfigReceiver {
    /**
     * List of email configurations.
     */
    emailConfigs: outputs.GetObservabilityInstanceAlertConfigReceiverEmailConfig[];
    /**
     * Name of the receiver.
     */
    name: string;
    /**
     * List of OpsGenie configurations.
     */
    opsgenieConfigs: outputs.GetObservabilityInstanceAlertConfigReceiverOpsgenieConfig[];
    /**
     * List of Webhooks configurations.
     */
    webhooksConfigs: outputs.GetObservabilityInstanceAlertConfigReceiverWebhooksConfig[];
}

export interface GetObservabilityInstanceAlertConfigReceiverEmailConfig {
    /**
     * SMTP authentication information. Must be a valid email address
     */
    authIdentity: string;
    /**
     * SMTP authentication password.
     */
    authPassword: string;
    /**
     * SMTP authentication username.
     */
    authUsername: string;
    /**
     * The sender email address. Must be a valid email address
     */
    from: string;
    /**
     * Whether to notify about resolved alerts.
     */
    sendResolved: boolean;
    /**
     * The SMTP host through which emails are sent.
     */
    smartHost: string;
    /**
     * The email address to send notifications to. Must be a valid email address
     */
    to: string;
}

export interface GetObservabilityInstanceAlertConfigReceiverOpsgenieConfig {
    /**
     * The API key for OpsGenie.
     */
    apiKey: string;
    /**
     * The host to send OpsGenie API requests to. Must be a valid URL
     */
    apiUrl: string;
    /**
     * Priority of the alert. Possible values are: `P1`, `P2`, `P3`, `P4`, `P5`.
     */
    priority: string;
    /**
     * Whether to notify about resolved alerts.
     */
    sendResolved: boolean;
    /**
     * Comma separated list of tags attached to the notifications.
     */
    tags: string;
}

export interface GetObservabilityInstanceAlertConfigReceiverWebhooksConfig {
    /**
     * Google Chat webhooks require special handling, set this to true if the webhook is for Google Chat.
     */
    googleChat: boolean;
    /**
     * Microsoft Teams webhooks require special handling, set this to true if the webhook is for Microsoft Teams.
     */
    msTeams: boolean;
    /**
     * Whether to notify about resolved alerts.
     */
    sendResolved: boolean;
    /**
     * The endpoint to send HTTP POST requests to. Must be a valid URL
     */
    url: string;
}

export interface GetObservabilityInstanceAlertConfigRoute {
    /**
     * The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
     */
    groupBies: string[];
    /**
     * How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
     */
    groupInterval: string;
    /**
     * How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.) .
     */
    groupWait: string;
    /**
     * The name of the receiver to route the alerts to.
     */
    receiver: string;
    /**
     * How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
     */
    repeatInterval: string;
    /**
     * List of child routes.
     */
    routes: outputs.GetObservabilityInstanceAlertConfigRouteRoute[];
}

export interface GetObservabilityInstanceAlertConfigRouteRoute {
    /**
     * Whether an alert should continue matching subsequent sibling nodes.
     */
    continue: boolean;
    /**
     * The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
     */
    groupBies: string[];
    /**
     * How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
     */
    groupInterval: string;
    /**
     * How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
     */
    groupWait: string;
    /**
     * A set of equality matchers an alert has to fulfill to match the node. This field is deprecated and will be removed after 10th March 2026, use `matchers` in the `routes` instead
     *
     * @deprecated Use `matchers` in the `routes` instead.
     */
    match: {[key: string]: string};
    /**
     * A set of regex-matchers an alert has to fulfill to match the node. This field is deprecated and will be removed after 10th March 2026, use `matchers` in the `routes` instead
     *
     * @deprecated Use `matchers` in the `routes` instead.
     */
    matchRegex: {[key: string]: string};
    /**
     * A list of matchers that an alert has to fulfill to match the node. A matcher is a string with a syntax inspired by PromQL and OpenMetrics.
     */
    matchers: string[];
    /**
     * The name of the receiver to route the alerts to.
     */
    receiver: string;
    /**
     * How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
     */
    repeatInterval: string;
}

export interface GetObservabilityLogalertgroupRule {
    /**
     * The name of the alert rule. Is the identifier and must be unique in the group.
     */
    alert: string;
    /**
     * A map of key:value. Annotations to add or overwrite for each alert
     */
    annotations: {[key: string]: string};
    /**
     * The LogQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and all resultant time series become pending/firing alerts.
     */
    expression: string;
    /**
     * Alerts are considered firing once they have been returned for this long. Alerts which have not yet fired for long enough are considered pending. Default is 0s
     */
    for: string;
    /**
     * A map of key:value. Labels to add or overwrite for each alert
     */
    labels: {[key: string]: string};
}

export interface GetObservabilityScrapeconfigBasicAuth {
    /**
     * Specifies basic auth password.
     */
    password: string;
    /**
     * Specifies basic auth username.
     */
    username: string;
}

export interface GetObservabilityScrapeconfigSaml2 {
    /**
     * Specifies if URL parameters are enabled
     */
    enableUrlParameters: boolean;
}

export interface GetObservabilityScrapeconfigTarget {
    /**
     * Specifies labels.
     */
    labels: {[key: string]: string};
    /**
     * Specifies target URLs.
     */
    urls: string[];
}

export interface GetOpensearchInstanceParameters {
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * If set, monitoring with Graphite will be enabled. Expects the host and port where the Graphite metrics should be sent to (host:port).
     */
    graphite: string;
    /**
     * The garbage collector to use for OpenSearch.
     */
    javaGarbageCollector: string;
    /**
     * The amount of memory (in MB) allocated as heap by the JVM for OpenSearch.
     */
    javaHeapspace: number;
    /**
     * The amount of memory (in MB) used by the JVM to store metadata for OpenSearch.
     */
    javaMaxmetaspace: number;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted (in seconds).
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key.
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * List of plugins to install. Must be a supported plugin name. The plugins `repository-s3` and `repository-azure` are enabled by default and cannot be disabled.
     */
    plugins: string[];
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
    /**
     * List of TLS ciphers to use.
     */
    tlsCiphers: string[];
    /**
     * The TLS protocol to use.
     */
    tlsProtocols: string;
}

export interface GetPostgresflexInstanceFlavor {
    cpu: number;
    description: string;
    id: string;
    ram: number;
}

export interface GetPostgresflexInstanceStorage {
    class: string;
    size: number;
}

export interface GetPublicIpRangesPublicIpRange {
    /**
     * Classless Inter-Domain Routing (CIDR)
     */
    cidr: string;
}

export interface GetRabbitmqInstanceParameters {
    /**
     * The timeout in milliseconds for the consumer.
     */
    consumerTimeout: number;
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * Graphite server URL (host and port). If set, monitoring with Graphite will be enabled.
     */
    graphite: string;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted.
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * List of plugins to install. Must be a supported plugin name.
     */
    plugins: string[];
    /**
     * List of roles to assign to the instance.
     */
    roles: string[];
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
    /**
     * List of TLS ciphers to use.
     */
    tlsCiphers: string[];
    /**
     * TLS protocol to use.
     */
    tlsProtocols: string;
}

export interface GetRedisInstanceParameters {
    /**
     * The number of milliseconds after which the instance is considered down.
     */
    downAfterMilliseconds: number;
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * The failover timeout in milliseconds.
     */
    failoverTimeout: number;
    /**
     * Graphite server URL (host and port). If set, monitoring with Graphite will be enabled.
     */
    graphite: string;
    /**
     * The lazy eviction enablement (yes or no).
     */
    lazyfreeLazyEviction: string;
    /**
     * The lazy expire enablement (yes or no).
     */
    lazyfreeLazyExpire: string;
    /**
     * The Lua time limit.
     */
    luaTimeLimit: number;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The maximum number of clients.
     */
    maxclients: number;
    /**
     * The policy to handle the maximum memory (volatile-lru, noeviction, etc).
     */
    maxmemoryPolicy: string;
    /**
     * The maximum memory samples.
     */
    maxmemorySamples: number;
    /**
     * The frequency in seconds at which metrics are emitted.
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key
     */
    metricsPrefix: string;
    /**
     * The minimum replicas maximum lag.
     */
    minReplicasMaxLag: number;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * The notify keyspace events.
     */
    notifyKeyspaceEvents: string;
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * The snapshot configuration.
     */
    snapshot: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
    /**
     * List of TLS ciphers to use.
     */
    tlsCiphers: string[];
    /**
     * TLS cipher suites to use.
     */
    tlsCiphersuites: string;
    /**
     * TLS protocol to use.
     */
    tlsProtocols: string;
}

export interface GetRoutingTableRouteDestination {
    /**
     * CIDRV type. Possible values are: `cidrv4`, `cidrv6`. Only `cidrv4` is supported during experimental stage.
     */
    type: string;
    /**
     * An CIDR string.
     */
    value: string;
}

export interface GetRoutingTableRouteNextHop {
    /**
     * Type of the next hop. Possible values are: `blackhole`, `internet`, `ipv4`, `ipv6`.
     */
    type: string;
    /**
     * Either IPv4 or IPv6 (not set for blackhole and internet). Only IPv4 supported during experimental stage.
     */
    value: string;
}

export interface GetRoutingTableRoutesRoute {
    /**
     * Date-time when the route was created
     */
    createdAt: string;
    /**
     * Destination of the route.
     */
    destination: outputs.GetRoutingTableRoutesRouteDestination;
    /**
     * Labels are key-value string pairs which can be attached to a resource container
     */
    labels: {[key: string]: string};
    /**
     * Next hop destination.
     */
    nextHop: outputs.GetRoutingTableRoutesRouteNextHop;
    /**
     * Route ID.
     */
    routeId: string;
    /**
     * Date-time when the route was updated
     */
    updatedAt: string;
}

export interface GetRoutingTableRoutesRouteDestination {
    /**
     * CIDRV type. Possible values are: `cidrv4`, `cidrv6`. Only `cidrv4` is supported during experimental stage.
     */
    type: string;
    /**
     * An CIDR string.
     */
    value: string;
}

export interface GetRoutingTableRoutesRouteNextHop {
    /**
     * Type of the next hop. Possible values are: `blackhole`, `internet`, `ipv4`, `ipv6`.
     */
    type: string;
    /**
     * Either IPv4 or IPv6 (not set for blackhole and internet). Only IPv4 supported during experimental stage.
     */
    value: string;
}

export interface GetRoutingTablesItem {
    /**
     * Date-time when the routing table was created
     */
    createdAt: string;
    /**
     * When true this is the default routing table for this network area. It can't be deleted and is used if the user does not specify it otherwise.
     */
    default: boolean;
    /**
     * Description of the routing table.
     */
    description: string;
    /**
     * This controls whether dynamic routes are propagated to this routing table
     */
    dynamicRoutes: boolean;
    /**
     * Labels are key-value string pairs which can be attached to a resource container
     */
    labels: {[key: string]: string};
    /**
     * The name of the routing table.
     */
    name: string;
    /**
     * The routing tables ID.
     */
    routingTableId: string;
    /**
     * This controls whether the routes for project-to-project communication are created automatically or not.
     */
    systemRoutes: boolean;
    /**
     * Date-time when the routing table was updated
     */
    updatedAt: string;
}

export interface GetSecurityGroupRuleIcmpParameters {
    /**
     * ICMP code. Can be set if the protocol is ICMP.
     */
    code: number;
    /**
     * ICMP type. Can be set if the protocol is ICMP.
     */
    type: number;
}

export interface GetSecurityGroupRulePortRange {
    /**
     * The maximum port number. Should be greater or equal to the minimum.
     */
    max: number;
    /**
     * The minimum port number. Should be less or equal to the minimum.
     */
    min: number;
}

export interface GetSecurityGroupRuleProtocol {
    /**
     * The protocol name which the rule should match.
     */
    name: string;
    /**
     * The protocol number which the rule should match.
     */
    number: number;
}

export interface GetServerBackupScheduleBackupProperties {
    name: string;
    retentionPeriod: number;
    volumeIds: string[];
}

export interface GetServerBackupSchedulesItem {
    /**
     * Backup schedule details for the backups.
     */
    backupProperties: outputs.GetServerBackupSchedulesItemBackupProperties;
    backupScheduleId: number;
    /**
     * Is the backup schedule enabled or disabled.
     */
    enabled: boolean;
    /**
     * The backup schedule name.
     */
    name: string;
    /**
     * Backup schedule described in `rrule` (recurrence rule) format.
     */
    rrule: string;
}

export interface GetServerBackupSchedulesItemBackupProperties {
    name: string;
    retentionPeriod: number;
    volumeIds: string[];
}

export interface GetServerBootVolume {
    /**
     * Delete the volume during the termination of the server.
     */
    deleteOnTermination: boolean;
    /**
     * The ID of the boot volume
     */
    id: string;
}

export interface GetServerUpdateSchedulesItem {
    /**
     * Is the update schedule enabled or disabled.
     */
    enabled: boolean;
    /**
     * Maintenance window [1..24].
     */
    maintenanceWindow: number;
    /**
     * The update schedule name.
     */
    name: string;
    /**
     * Update schedule described in `rrule` (recurrence rule) format.
     */
    rrule: string;
    updateScheduleId: number;
}

export interface GetSfsExportPolicyRule {
    /**
     * Description of the Rule
     */
    description?: string;
    /**
     * IP access control list; IPs must have a subnet mask (e.g. "172.16.0.0/24" for a range of IPs, or "172.16.0.250/32" for a specific IP).
     */
    ipAcls: string[];
    /**
     * Order of the rule within a Share Export Policy. The order is used so that when a client IP matches multiple rules, the first rule is applied
     */
    order: number;
    /**
     * Flag to indicate if client IPs matching this rule can only mount the share in read only mode
     */
    readOnly: boolean;
    /**
     * Flag to honor set UUID
     */
    setUuid: boolean;
    /**
     * Flag to indicate if client IPs matching this rule have root access on the Share
     */
    superUser: boolean;
}

export interface GetSfsResourcePoolSnapshotSnapshot {
    /**
     * (optional) A comment to add more information about a snapshot
     */
    comment: string;
    /**
     * creation date of the snapshot
     */
    createdAt: string;
    /**
     * Represents the user-visible data size at the time of the snapshot (e.g. whatâ€™s in the snapshot)
     */
    logicalSizeGigabytes: number;
    /**
     * ID of the Resource Pool of the Snapshot
     */
    resourcePoolId: string;
    /**
     * Reflects the actual storage footprint in the backend at snapshot time (e.g. how much storage from the Resource Pool does it use)
     */
    sizeGigabytes: number;
    /**
     * Name of the Resource Pool Snapshot
     */
    snapshotName: string;
}

export interface GetSkeClusterExtensions {
    /**
     * Cluster access control configuration
     */
    acl: outputs.GetSkeClusterExtensionsAcl;
    /**
     * A single argus block as defined below. This field is deprecated and will be removed 06 January 2026.
     *
     * @deprecated Use observability instead.
     */
    argus: outputs.GetSkeClusterExtensionsArgus;
    /**
     * DNS extension configuration
     */
    dns: outputs.GetSkeClusterExtensionsDns;
    /**
     * A single observability block as defined below.
     */
    observability: outputs.GetSkeClusterExtensionsObservability;
}

export interface GetSkeClusterExtensionsAcl {
    /**
     * Specify a list of CIDRs to whitelist
     */
    allowedCidrs: string[];
    /**
     * Is ACL enabled?
     */
    enabled: boolean;
}

export interface GetSkeClusterExtensionsArgus {
    /**
     * Instance ID of argus
     */
    argusInstanceId: string;
    /**
     * Flag to enable/disable argus extensions.
     */
    enabled: boolean;
}

export interface GetSkeClusterExtensionsDns {
    /**
     * Flag to enable/disable DNS extensions
     */
    enabled: boolean;
    /**
     * Specify a list of domain filters for externalDNS (e.g., `foo.runs.onstackit.cloud`)
     */
    zones: string[];
}

export interface GetSkeClusterExtensionsObservability {
    /**
     * Flag to enable/disable Observability extensions.
     */
    enabled: boolean;
    /**
     * Observability instance ID to choose which Observability instance is used. Required when enabled is set to `true`.
     */
    instanceId: string;
}

export interface GetSkeClusterHibernation {
    /**
     * End time of hibernation, in crontab syntax.
     */
    end: string;
    /**
     * Start time of cluster hibernation in crontab syntax.
     */
    start: string;
    /**
     * Timezone name corresponding to a file in the IANA Time Zone database.
     */
    timezone: string;
}

export interface GetSkeClusterMaintenance {
    /**
     * Flag to enable/disable auto-updates of the Kubernetes version.
     */
    enableKubernetesVersionUpdates: boolean;
    /**
     * Flag to enable/disable auto-updates of the OS image version.
     */
    enableMachineImageVersionUpdates: boolean;
    /**
     * Date time for maintenance window end.
     */
    end: string;
    /**
     * Date time for maintenance window start.
     */
    start: string;
}

export interface GetSkeClusterNetwork {
    /**
     * ID of the STACKIT Network Area (SNA) network into which the cluster will be deployed.
     */
    id: string;
}

export interface GetSkeClusterNodePool {
    /**
     * Allow system components to run on this node pool.
     */
    allowSystemComponents: boolean;
    /**
     * Specify a list of availability zones.
     */
    availabilityZones: string[];
    /**
     * Specifies the container runtime.
     */
    cri: string;
    /**
     * Labels to add to each node.
     */
    labels: {[key: string]: string};
    /**
     * The machine type.
     */
    machineType: string;
    /**
     * The maximum number of nodes upgraded simultaneously.
     */
    maxSurge: number;
    /**
     * The maximum number of nodes unavailable during upgraded.
     */
    maxUnavailable: number;
    /**
     * Maximum number of nodes in the pool.
     */
    maximum: number;
    /**
     * Minimum number of nodes in the pool.
     */
    minimum: number;
    /**
     * Specifies the name of the node pool.
     */
    name: string;
    /**
     * The name of the OS image.
     */
    osName: string;
    /**
     * The OS image version.
     */
    osVersion: string;
    /**
     * The minimum OS image version, this field is always nil. SKE automatically updates the cluster Kubernetes version if you have set `maintenance.enable_kubernetes_version_updates` to true or if there is a mandatory update, as described in [General information for Kubernetes & OS updates](https://docs.stackit.cloud/products/runtime/kubernetes-engine/basics/version-updates/). To get the current OS image version being used for the node pool, use the read-only `osVersionUsed` field.
     */
    osVersionMin: string;
    /**
     * Full OS image version used. For example, if 3815.2 was set in `osVersionMin`, this value may result to 3815.2.2. SKE automatically updates the cluster Kubernetes version if you have set `maintenance.enable_kubernetes_version_updates` to true or if there is a mandatory update, as described in [General information for Kubernetes & OS updates](https://docs.stackit.cloud/products/runtime/kubernetes-engine/basics/version-updates/).
     */
    osVersionUsed: string;
    /**
     * Specifies a taint list as defined below.
     */
    taints: outputs.GetSkeClusterNodePoolTaint[];
    /**
     * The volume size in GB.
     */
    volumeSize: number;
    /**
     * Specifies the volume type.
     */
    volumeType: string;
}

export interface GetSkeClusterNodePoolTaint {
    /**
     * The taint effect.
     */
    effect: string;
    /**
     * Taint key to be applied to a node.
     */
    key: string;
    /**
     * Taint value corresponding to the taint key.
     */
    value: string;
}

export interface GetSqlserverflexInstanceFlavor {
    cpu: number;
    description: string;
    id: string;
    ram: number;
}

export interface GetSqlserverflexInstanceOptions {
    edition: string;
    retentionDays: number;
}

export interface GetSqlserverflexInstanceStorage {
    class: string;
    size: number;
}

export interface GetVolumeSource {
    /**
     * The ID of the source, e.g. image ID
     */
    id: string;
    /**
     * The type of the source. Possible values are: `volume`, `image`, `snapshot`, `backup`.
     */
    type: string;
}

export interface ImageChecksum {
    /**
     * Algorithm for the checksum of the image data.
     */
    algorithm: string;
    /**
     * Hexdigest of the checksum of the image data.
     */
    digest: string;
}

export interface ImageConfig {
    /**
     * Enables the BIOS bootmenu.
     */
    bootMenu: boolean;
    /**
     * Sets CDROM bus controller type.
     */
    cdromBus: string;
    /**
     * Sets Disk bus controller type.
     */
    diskBus: string;
    /**
     * Sets virtual network interface model.
     */
    nicModel: string;
    /**
     * Enables operating system specific optimizations.
     */
    operatingSystem: string;
    /**
     * Operating system distribution.
     */
    operatingSystemDistro: string;
    /**
     * Version of the operating system.
     */
    operatingSystemVersion: string;
    /**
     * Sets the device bus when the image is used as a rescue image.
     */
    rescueBus: string;
    /**
     * Sets the device when the image is used as a rescue image.
     */
    rescueDevice: string;
    /**
     * Enables Secure Boot.
     */
    secureBoot: boolean;
    /**
     * Enables UEFI boot.
     */
    uefi: boolean;
    /**
     * Sets Graphic device model.
     */
    videoModel: string;
    /**
     * Enables the use of VirtIO SCSI to provide block device access. By default instances use VirtIO Block.
     */
    virtioScsi: boolean;
}

export interface LoadbalancerListener {
    displayName: string;
    /**
     * Port number where we listen for traffic.
     */
    port: number;
    /**
     * Protocol is the highest network protocol we understand to load balance. Possible values are: `PROTOCOL_UNSPECIFIED`, `PROTOCOL_TCP`, `PROTOCOL_UDP`, `PROTOCOL_TCP_PROXY`, `PROTOCOL_TLS_PASSTHROUGH`.
     */
    protocol: string;
    /**
     * A list of domain names to match in order to pass TLS traffic to the target pool in the current listener
     */
    serverNameIndicators?: outputs.LoadbalancerListenerServerNameIndicator[];
    /**
     * Reference target pool by target pool name.
     */
    targetPool: string;
    /**
     * Options that are specific to the TCP protocol.
     */
    tcp?: outputs.LoadbalancerListenerTcp;
    /**
     * Options that are specific to the UDP protocol.
     */
    udp?: outputs.LoadbalancerListenerUdp;
}

export interface LoadbalancerListenerServerNameIndicator {
    /**
     * A domain name to match in order to pass TLS traffic to the target pool in the current listener
     */
    name?: string;
}

export interface LoadbalancerListenerTcp {
    /**
     * Time after which an idle connection is closed. The default value is set to 300 seconds, and the maximum value is 3600 seconds. The format is a duration and the unit must be seconds. Example: 30s
     */
    idleTimeout?: string;
}

export interface LoadbalancerListenerUdp {
    /**
     * Time after which an idle session is closed. The default value is set to 1 minute, and the maximum value is 2 minutes. The format is a duration and the unit must be seconds. Example: 30s
     */
    idleTimeout?: string;
}

export interface LoadbalancerNetwork {
    /**
     * Openstack network ID.
     */
    networkId: string;
    /**
     * The role defines how the load balancer is using the network. Possible values are: `ROLE_UNSPECIFIED`, `ROLE_LISTENERS_AND_TARGETS`, `ROLE_LISTENERS`, `ROLE_TARGETS`.
     */
    role: string;
}

export interface LoadbalancerOptions {
    /**
     * Load Balancer is accessible only from an IP address in this range.
     */
    acls: string[];
    /**
     * We offer Load Balancer metrics observability via ARGUS or external solutions. Not changeable after creation.
     */
    observability: outputs.LoadbalancerOptionsObservability;
    /**
     * If true, Load Balancer is accessible only via a private network IP address.
     */
    privateNetworkOnly: boolean;
}

export interface LoadbalancerOptionsObservability {
    /**
     * Observability logs configuration. Not changeable after creation.
     */
    logs: outputs.LoadbalancerOptionsObservabilityLogs;
    /**
     * Observability metrics configuration. Not changeable after creation.
     */
    metrics: outputs.LoadbalancerOptionsObservabilityMetrics;
}

export interface LoadbalancerOptionsObservabilityLogs {
    /**
     * Credentials reference for logs. Not changeable after creation.
     */
    credentialsRef: string;
    /**
     * Credentials reference for logs. Not changeable after creation.
     */
    pushUrl: string;
}

export interface LoadbalancerOptionsObservabilityMetrics {
    /**
     * Credentials reference for metrics. Not changeable after creation.
     */
    credentialsRef: string;
    /**
     * Credentials reference for metrics. Not changeable after creation.
     */
    pushUrl: string;
}

export interface LoadbalancerTargetPool {
    activeHealthCheck: outputs.LoadbalancerTargetPoolActiveHealthCheck;
    /**
     * Target pool name.
     */
    name: string;
    /**
     * Here you can setup various session persistence options, so far only "`useSourceIpAddress`" is supported.
     */
    sessionPersistence?: outputs.LoadbalancerTargetPoolSessionPersistence;
    /**
     * Identical port number where each target listens for traffic.
     */
    targetPort: number;
    /**
     * List of all targets which will be used in the pool. Limited to 1000.
     */
    targets: outputs.LoadbalancerTargetPoolTarget[];
}

export interface LoadbalancerTargetPoolActiveHealthCheck {
    /**
     * Healthy threshold of the health checking.
     */
    healthyThreshold: number;
    /**
     * Interval duration of health checking in seconds.
     */
    interval: string;
    /**
     * Interval duration threshold of the health checking in seconds.
     */
    intervalJitter: string;
    /**
     * Active health checking timeout duration in seconds.
     */
    timeout: string;
    /**
     * Unhealthy threshold of the health checking.
     */
    unhealthyThreshold: number;
}

export interface LoadbalancerTargetPoolSessionPersistence {
    /**
     * If true then all connections from one source IP address are redirected to the same target. This setting changes the load balancing algorithm to Maglev.
     */
    useSourceIpAddress?: boolean;
}

export interface LoadbalancerTargetPoolTarget {
    /**
     * Target display name
     */
    displayName: string;
    /**
     * Target IP
     */
    ip: string;
}

export interface LogmeInstanceParameters {
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    fluentdTcp: number;
    fluentdTls: number;
    fluentdTlsCiphers: string;
    fluentdTlsMaxVersion: string;
    fluentdTlsMinVersion: string;
    fluentdTlsVersion: string;
    fluentdUdp: number;
    /**
     * If set, monitoring with Graphite will be enabled. Expects the host and port where the Graphite metrics should be sent to (host:port).
     */
    graphite: string;
    /**
     * Combination of an integer and a timerange when an index will be considered "old" and can be deleted. Possible values for the timerange are `s`, `m`, `h` and `d`.
     */
    ismDeletionAfter: string;
    ismJitter: number;
    /**
     * Jitter of the execution time.
     */
    ismJobInterval: number;
    /**
     * The amount of memory (in MB) allocated as heap by the JVM for OpenSearch.
     */
    javaHeapspace: number;
    /**
     * The amount of memory (in MB) used by the JVM to store metadata for OpenSearch.
     */
    javaMaxmetaspace: number;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted (in seconds).
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key.
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    opensearchTlsCiphers: string[];
    opensearchTlsProtocols: string[];
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
}

export interface MariadbInstanceParameters {
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * Graphite server URL (host and port). If set, monitoring with Graphite will be enabled.
     */
    graphite: string;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted.
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance. Monitoring instances with the plan "Observability-Monitoring-Starter" are not supported.
     */
    monitoringInstanceId: string;
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
}

export interface MongodbflexInstanceFlavor {
    cpu: number;
    description: string;
    id: string;
    ram: number;
}

export interface MongodbflexInstanceOptions {
    /**
     * The number of days that daily backups will be retained.
     */
    dailySnapshotRetentionDays: number;
    /**
     * The number of months that monthly backups will be retained.
     */
    monthlySnapshotRetentionMonths: number;
    /**
     * The number of hours back in time the point-in-time recovery feature will be able to recover.
     */
    pointInTimeWindowHours: number;
    /**
     * The number of days that continuous backups (controlled via the `backupSchedule`) will be retained.
     */
    snapshotRetentionDays: number;
    /**
     * Type of the MongoDB Flex instance. Possible values are: `Replica`, `Sharded`, `Single`.
     */
    type: string;
    /**
     * The number of weeks that weekly backups will be retained.
     */
    weeklySnapshotRetentionWeeks: number;
}

export interface MongodbflexInstanceStorage {
    class: string;
    size: number;
}

export interface NetworkAreaNetworkRange {
    /**
     * @deprecated Deprecated because of the IaaS API v1 -> v2 migration. Will be removed in May 2026. Use the new `stackit.NetworkAreaRegion` resource instead.
     */
    networkRangeId: string;
    /**
     * Classless Inter-Domain Routing (CIDR).
     *
     * @deprecated Deprecated because of the IaaS API v1 -> v2 migration. Will be removed in May 2026. Use the new `stackit.NetworkAreaRegion` resource instead.
     */
    prefix: string;
}

export interface NetworkAreaRegionIpv4 {
    /**
     * List of DNS Servers/Nameservers.
     */
    defaultNameservers?: string[];
    /**
     * The default prefix length for networks in the network area.
     */
    defaultPrefixLength: number;
    /**
     * The maximal prefix length for networks in the network area.
     */
    maxPrefixLength: number;
    /**
     * The minimal prefix length for networks in the network area.
     */
    minPrefixLength: number;
    /**
     * List of Network ranges.
     */
    networkRanges: outputs.NetworkAreaRegionIpv4NetworkRange[];
    /**
     * IPv4 Classless Inter-Domain Routing (CIDR).
     */
    transferNetwork: string;
}

export interface NetworkAreaRegionIpv4NetworkRange {
    networkRangeId: string;
    /**
     * Classless Inter-Domain Routing (CIDR).
     */
    prefix: string;
}

export interface NetworkAreaRouteDestination {
    /**
     * CIDRV type. Possible values are: `cidrv4`, `cidrv6`. Only `cidrv4` is supported currently.
     */
    type: string;
    /**
     * An CIDR string.
     */
    value: string;
}

export interface NetworkAreaRouteNextHop {
    /**
     * Type of the next hop. Possible values are: `blackhole`, `internet`, `ipv4`, `ipv6`. Only `ipv4` supported currently.
     */
    type: string;
    /**
     * Either IPv4 or IPv6 (not set for blackhole and internet). Only IPv4 supported currently.
     */
    value?: string;
}

export interface ObservabilityAlertgroupRule {
    /**
     * The name of the alert rule. Is the identifier and must be unique in the group.
     */
    alert: string;
    /**
     * A map of key:value. Annotations to add or overwrite for each alert
     */
    annotations?: {[key: string]: string};
    /**
     * The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and all resultant time series become pending/firing alerts.
     */
    expression: string;
    /**
     * Alerts are considered firing once they have been returned for this long. Alerts which have not yet fired for long enough are considered pending. Default is 0s
     */
    for?: string;
    /**
     * A map of key:value. Labels to add or overwrite for each alert
     */
    labels?: {[key: string]: string};
}

export interface ObservabilityInstanceAlertConfig {
    /**
     * Global configuration for the alerts. If nothing passed the default argus config will be used. It is only possible to update the entire global part, not individual attributes.
     */
    global: outputs.ObservabilityInstanceAlertConfigGlobal;
    /**
     * List of alert receivers.
     */
    receivers: outputs.ObservabilityInstanceAlertConfigReceiver[];
    /**
     * Route configuration for the alerts.
     */
    route: outputs.ObservabilityInstanceAlertConfigRoute;
}

export interface ObservabilityInstanceAlertConfigGlobal {
    /**
     * The API key for OpsGenie.
     */
    opsgenieApiKey: string;
    /**
     * The host to send OpsGenie API requests to. Must be a valid URL
     */
    opsgenieApiUrl: string;
    /**
     * The default value used by alertmanager if the alert does not include EndsAt. After this time passes, it can declare the alert as resolved if it has not been updated. This has no impact on alerts from Prometheus, as they always include EndsAt.
     */
    resolveTimeout: string;
    /**
     * SMTP authentication information. Must be a valid email address
     */
    smtpAuthIdentity: string;
    /**
     * SMTP Auth using LOGIN and PLAIN.
     */
    smtpAuthPassword: string;
    /**
     * SMTP Auth using CRAM-MD5, LOGIN and PLAIN. If empty, Alertmanager doesn't authenticate to the SMTP server.
     */
    smtpAuthUsername: string;
    /**
     * The default SMTP From header field. Must be a valid email address
     */
    smtpFrom: string;
    /**
     * The default SMTP smarthost used for sending emails, including port number in format `host:port` (eg. `smtp.example.com:587`). Port number usually is 25, or 587 for SMTP over TLS (sometimes referred to as STARTTLS).
     */
    smtpSmartHost: string;
}

export interface ObservabilityInstanceAlertConfigReceiver {
    /**
     * List of email configurations.
     */
    emailConfigs?: outputs.ObservabilityInstanceAlertConfigReceiverEmailConfig[];
    /**
     * Name of the receiver.
     */
    name: string;
    /**
     * List of OpsGenie configurations.
     */
    opsgenieConfigs?: outputs.ObservabilityInstanceAlertConfigReceiverOpsgenieConfig[];
    /**
     * List of Webhooks configurations.
     */
    webhooksConfigs?: outputs.ObservabilityInstanceAlertConfigReceiverWebhooksConfig[];
}

export interface ObservabilityInstanceAlertConfigReceiverEmailConfig {
    /**
     * SMTP authentication information. Must be a valid email address
     */
    authIdentity?: string;
    /**
     * SMTP authentication password.
     */
    authPassword?: string;
    /**
     * SMTP authentication username.
     */
    authUsername?: string;
    /**
     * The sender email address. Must be a valid email address
     */
    from?: string;
    /**
     * Whether to notify about resolved alerts.
     */
    sendResolved: boolean;
    /**
     * The SMTP host through which emails are sent.
     */
    smartHost?: string;
    /**
     * The email address to send notifications to. Must be a valid email address
     */
    to?: string;
}

export interface ObservabilityInstanceAlertConfigReceiverOpsgenieConfig {
    /**
     * The API key for OpsGenie.
     */
    apiKey?: string;
    /**
     * The host to send OpsGenie API requests to. Must be a valid URL
     */
    apiUrl?: string;
    /**
     * Priority of the alert. Possible values are: `P1`, `P2`, `P3`, `P4`, `P5`.
     */
    priority?: string;
    /**
     * Whether to notify about resolved alerts.
     */
    sendResolved: boolean;
    /**
     * Comma separated list of tags attached to the notifications.
     */
    tags?: string;
}

export interface ObservabilityInstanceAlertConfigReceiverWebhooksConfig {
    /**
     * Google Chat webhooks require special handling, set this to true if the webhook is for Google Chat.
     */
    googleChat: boolean;
    /**
     * Microsoft Teams webhooks require special handling, set this to true if the webhook is for Microsoft Teams.
     */
    msTeams: boolean;
    /**
     * Whether to notify about resolved alerts.
     */
    sendResolved: boolean;
    /**
     * The endpoint to send HTTP POST requests to. Must be a valid URL
     */
    url?: string;
}

export interface ObservabilityInstanceAlertConfigRoute {
    /**
     * The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
     */
    groupBies?: string[];
    /**
     * How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
     */
    groupInterval: string;
    /**
     * How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
     */
    groupWait: string;
    /**
     * The name of the receiver to route the alerts to.
     */
    receiver: string;
    /**
     * How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
     */
    repeatInterval: string;
    /**
     * List of child routes.
     */
    routes?: outputs.ObservabilityInstanceAlertConfigRouteRoute[];
}

export interface ObservabilityInstanceAlertConfigRouteRoute {
    /**
     * Whether an alert should continue matching subsequent sibling nodes.
     */
    continue?: boolean;
    /**
     * The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
     */
    groupBies?: string[];
    /**
     * How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
     */
    groupInterval: string;
    /**
     * How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
     */
    groupWait: string;
    /**
     * A set of equality matchers an alert has to fulfill to match the node. This field is deprecated and will be removed after 10th March 2026, use `matchers` in the `routes` instead
     *
     * @deprecated Use `matchers` in the `routes` instead.
     */
    match?: {[key: string]: string};
    /**
     * A set of regex-matchers an alert has to fulfill to match the node. This field is deprecated and will be removed after 10th March 2026, use `matchers` in the `routes` instead
     *
     * @deprecated Use `matchers` in the `routes` instead.
     */
    matchRegex?: {[key: string]: string};
    /**
     * A list of matchers that an alert has to fulfill to match the node. A matcher is a string with a syntax inspired by PromQL and OpenMetrics.
     */
    matchers?: string[];
    /**
     * The name of the receiver to route the alerts to.
     */
    receiver: string;
    /**
     * How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
     */
    repeatInterval: string;
}

export interface ObservabilityLogalertgroupRule {
    /**
     * The name of the alert rule. Is the identifier and must be unique in the group.
     */
    alert: string;
    /**
     * A map of key:value. Annotations to add or overwrite for each alert
     */
    annotations?: {[key: string]: string};
    /**
     * The LogQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and all resultant time series become pending/firing alerts.
     */
    expression: string;
    /**
     * Alerts are considered firing once they have been returned for this long. Alerts which have not yet fired for long enough are considered pending. Default is 0s
     */
    for?: string;
    /**
     * A map of key:value. Labels to add or overwrite for each alert
     */
    labels?: {[key: string]: string};
}

export interface ObservabilityScrapeconfigBasicAuth {
    /**
     * Specifies basic auth password.
     */
    password: string;
    /**
     * Specifies basic auth username.
     */
    username: string;
}

export interface ObservabilityScrapeconfigSaml2 {
    /**
     * Specifies if URL parameters are enabled. Defaults to `true`
     */
    enableUrlParameters: boolean;
}

export interface ObservabilityScrapeconfigTarget {
    /**
     * Specifies labels.
     */
    labels?: {[key: string]: string};
    /**
     * Specifies target URLs.
     */
    urls: string[];
}

export interface OpensearchInstanceParameters {
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * If set, monitoring with Graphite will be enabled. Expects the host and port where the Graphite metrics should be sent to (host:port).
     */
    graphite: string;
    /**
     * The garbage collector to use for OpenSearch.
     */
    javaGarbageCollector: string;
    /**
     * The amount of memory (in MB) allocated as heap by the JVM for OpenSearch.
     */
    javaHeapspace: number;
    /**
     * The amount of memory (in MB) used by the JVM to store metadata for OpenSearch.
     */
    javaMaxmetaspace: number;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted (in seconds).
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key.
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * List of plugins to install. Must be a supported plugin name. The plugins `repository-s3` and `repository-azure` are enabled by default and cannot be disabled.
     */
    plugins: string[];
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
    /**
     * List of TLS ciphers to use.
     */
    tlsCiphers: string[];
    /**
     * The TLS protocol to use.
     */
    tlsProtocols: string[];
}

export interface PostgresflexInstanceFlavor {
    cpu: number;
    description: string;
    id: string;
    ram: number;
}

export interface PostgresflexInstanceStorage {
    class: string;
    size: number;
}

export interface RabbitmqInstanceParameters {
    /**
     * The timeout in milliseconds for the consumer.
     */
    consumerTimeout: number;
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * Graphite server URL (host and port). If set, monitoring with Graphite will be enabled.
     */
    graphite: string;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The frequency in seconds at which metrics are emitted.
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key
     */
    metricsPrefix: string;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * List of plugins to install. Must be a supported plugin name.
     */
    plugins: string[];
    /**
     * List of roles to assign to the instance.
     */
    roles: string[];
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
    /**
     * List of TLS ciphers to use.
     */
    tlsCiphers: string[];
    /**
     * TLS protocol to use.
     */
    tlsProtocols: string;
}

export interface RedisInstanceParameters {
    /**
     * The number of milliseconds after which the instance is considered down.
     */
    downAfterMilliseconds: number;
    /**
     * Enable monitoring.
     */
    enableMonitoring: boolean;
    /**
     * The failover timeout in milliseconds.
     */
    failoverTimeout: number;
    /**
     * Graphite server URL (host and port). If set, monitoring with Graphite will be enabled.
     */
    graphite: string;
    /**
     * The lazy eviction enablement (yes or no).
     */
    lazyfreeLazyEviction: string;
    /**
     * The lazy expire enablement (yes or no).
     */
    lazyfreeLazyExpire: string;
    /**
     * The Lua time limit.
     */
    luaTimeLimit: number;
    /**
     * The maximum disk threshold in MB. If the disk usage exceeds this threshold, the instance will be stopped.
     */
    maxDiskThreshold: number;
    /**
     * The maximum number of clients.
     */
    maxclients: number;
    /**
     * The policy to handle the maximum memory (volatile-lru, noeviction, etc).
     */
    maxmemoryPolicy: string;
    /**
     * The maximum memory samples.
     */
    maxmemorySamples: number;
    /**
     * The frequency in seconds at which metrics are emitted.
     */
    metricsFrequency: number;
    /**
     * The prefix for the metrics. Could be useful when using Graphite monitoring to prefix the metrics with a certain value, like an API key
     */
    metricsPrefix: string;
    /**
     * The minimum replicas maximum lag.
     */
    minReplicasMaxLag: number;
    /**
     * The ID of the STACKIT monitoring instance.
     */
    monitoringInstanceId: string;
    /**
     * The notify keyspace events.
     */
    notifyKeyspaceEvents: string;
    /**
     * Comma separated list of IP networks in CIDR notation which are allowed to access this instance.
     */
    sgwAcl: string;
    /**
     * The snapshot configuration.
     */
    snapshot: string;
    /**
     * List of syslog servers to send logs to.
     */
    syslogs: string[];
    /**
     * List of TLS ciphers to use.
     */
    tlsCiphers: string[];
    /**
     * TLS cipher suites to use.
     */
    tlsCiphersuites: string;
    /**
     * TLS protocol to use.
     */
    tlsProtocols: string;
}

export interface RoutingTableRouteDestination {
    /**
     * CIDRV type. Possible values are: `cidrv4`, `cidrv6`. Only `cidrv4` is supported during experimental stage.
     */
    type: string;
    /**
     * An CIDR string.
     */
    value: string;
}

export interface RoutingTableRouteNextHop {
    /**
     * Type of the next hop. Possible values are: `blackhole`, `internet`, `ipv4`, `ipv6`.
     */
    type: string;
    /**
     * Either IPv4 or IPv6 (not set for blackhole and internet). Only IPv4 supported during experimental stage.
     */
    value?: string;
}

export interface SecurityGroupRuleIcmpParameters {
    /**
     * ICMP code. Can be set if the protocol is ICMP.
     */
    code: number;
    /**
     * ICMP type. Can be set if the protocol is ICMP.
     */
    type: number;
}

export interface SecurityGroupRulePortRange {
    /**
     * The maximum port number. Should be greater or equal to the minimum.
     */
    max: number;
    /**
     * The minimum port number. Should be less or equal to the maximum.
     */
    min: number;
}

export interface SecurityGroupRuleProtocol {
    /**
     * The protocol name which the rule should match. Either `name` or `number` must be provided. Possible values are: `ah`, `dccp`, `egp`, `esp`, `gre`, `icmp`, `igmp`, `ipip`, `ipv6-encap`, `ipv6-frag`, `ipv6-icmp`, `ipv6-nonxt`, `ipv6-opts`, `ipv6-route`, `ospf`, `pgm`, `rsvp`, `sctp`, `tcp`, `udp`, `udplite`, `vrrp`.
     */
    name: string;
    /**
     * The protocol number which the rule should match. Either `name` or `number` must be provided.
     */
    number: number;
}

export interface ServerBackupScheduleBackupProperties {
    name: string;
    retentionPeriod: number;
    volumeIds?: string[];
}

export interface ServerBootVolume {
    /**
     * Delete the volume during the termination of the server. Only allowed when `sourceType` is `image`.
     */
    deleteOnTermination: boolean;
    /**
     * The ID of the boot volume
     */
    id: string;
    /**
     * The performance class of the server.
     */
    performanceClass?: string;
    /**
     * The size of the boot volume in GB. Must be provided when `sourceType` is `image`.
     */
    size?: number;
    /**
     * The ID of the source, either image ID or volume ID
     */
    sourceId: string;
    /**
     * The type of the source. Possible values are: `volume`, `image`.
     */
    sourceType: string;
}

export interface SfsExportPolicyRule {
    /**
     * Description of the Rule
     */
    description?: string;
    /**
     * IP access control list; IPs must have a subnet mask (e.g. "172.16.0.0/24" for a range of IPs, or "172.16.0.250/32" for a specific IP).
     */
    ipAcls: string[];
    /**
     * Order of the rule within a Share Export Policy. The order is used so that when a client IP matches multiple rules, the first rule is applied
     */
    order: number;
    /**
     * Flag to indicate if client IPs matching this rule can only mount the share in read only mode
     */
    readOnly: boolean;
    /**
     * Flag to honor set UUID
     */
    setUuid: boolean;
    /**
     * Flag to indicate if client IPs matching this rule have root access on the Share
     */
    superUser: boolean;
}

export interface SkeClusterExtensions {
    /**
     * Cluster access control configuration.
     */
    acl?: outputs.SkeClusterExtensionsAcl;
    /**
     * A single argus block as defined below. This field is deprecated and will be removed 06 January 2026.
     *
     * @deprecated Use observability instead.
     */
    argus?: outputs.SkeClusterExtensionsArgus;
    /**
     * DNS extension configuration
     */
    dns?: outputs.SkeClusterExtensionsDns;
    /**
     * A single observability block as defined below.
     */
    observability?: outputs.SkeClusterExtensionsObservability;
}

export interface SkeClusterExtensionsAcl {
    /**
     * Specify a list of CIDRs to whitelist.
     */
    allowedCidrs: string[];
    /**
     * Is ACL enabled?
     */
    enabled: boolean;
}

export interface SkeClusterExtensionsArgus {
    /**
     * Argus instance ID to choose which Argus instance is used. Required when enabled is set to `true`.
     */
    argusInstanceId?: string;
    /**
     * Flag to enable/disable Argus extensions.
     */
    enabled: boolean;
}

export interface SkeClusterExtensionsDns {
    /**
     * Flag to enable/disable DNS extensions
     */
    enabled: boolean;
    /**
     * Specify a list of domain filters for externalDNS (e.g., `foo.runs.onstackit.cloud`)
     */
    zones: string[];
}

export interface SkeClusterExtensionsObservability {
    /**
     * Flag to enable/disable Observability extensions.
     */
    enabled: boolean;
    /**
     * Observability instance ID to choose which Observability instance is used. Required when enabled is set to `true`.
     */
    instanceId?: string;
}

export interface SkeClusterHibernation {
    /**
     * End time of hibernation in crontab syntax. E.g. `0 8 * * *` for waking up the cluster at 8am.
     */
    end: string;
    /**
     * Start time of cluster hibernation in crontab syntax. E.g. `0 18 * * *` for starting everyday at 6pm.
     */
    start: string;
    /**
     * Timezone name corresponding to a file in the IANA Time Zone database. i.e. `Europe/Berlin`.
     */
    timezone: string;
}

export interface SkeClusterMaintenance {
    /**
     * Flag to enable/disable auto-updates of the Kubernetes version. Defaults to `true`. SKE automatically updates the cluster Kubernetes version if you have set `maintenance.enable_kubernetes_version_updates` to true or if there is a mandatory update, as described in [General information for Kubernetes & OS updates](https://docs.stackit.cloud/products/runtime/kubernetes-engine/basics/version-updates/).
     */
    enableKubernetesVersionUpdates: boolean;
    /**
     * Flag to enable/disable auto-updates of the OS image version. Defaults to `true`. SKE automatically updates the cluster Kubernetes version if you have set `maintenance.enable_kubernetes_version_updates` to true or if there is a mandatory update, as described in [General information for Kubernetes & OS updates](https://docs.stackit.cloud/products/runtime/kubernetes-engine/basics/version-updates/).
     */
    enableMachineImageVersionUpdates: boolean;
    /**
     * Time for maintenance window end. E.g. `01:23:45Z`, `05:00:00+02:00`.
     */
    end: string;
    /**
     * Time for maintenance window start. E.g. `01:23:45Z`, `05:00:00+02:00`.
     */
    start: string;
}

export interface SkeClusterNetwork {
    /**
     * ID of the STACKIT Network Area (SNA) network into which the cluster will be deployed.
     */
    id?: string;
}

export interface SkeClusterNodePool {
    /**
     * Allow system components to run on this node pool.
     */
    allowSystemComponents: boolean;
    /**
     * Specify a list of availability zones. E.g. `eu01-m`
     */
    availabilityZones: string[];
    /**
     * Specifies the container runtime. Defaults to `containerd`
     */
    cri: string;
    /**
     * Labels to add to each node.
     */
    labels: {[key: string]: string};
    /**
     * The machine type.
     */
    machineType: string;
    /**
     * Maximum number of additional VMs that are created during an update. If set (larger than 0), then it must be at least the amount of zones configured for the nodepool. The `maxSurge` and `maxUnavailable` fields cannot both be unset at the same time.
     */
    maxSurge: number;
    /**
     * Maximum number of VMs that that can be unavailable during an update. If set (larger than 0), then it must be at least the amount of zones configured for the nodepool. The `maxSurge` and `maxUnavailable` fields cannot both be unset at the same time.
     */
    maxUnavailable: number;
    /**
     * Maximum number of nodes in the pool.
     */
    maximum: number;
    /**
     * Minimum number of nodes in the pool.
     */
    minimum: number;
    /**
     * Specifies the name of the node pool.
     */
    name: string;
    /**
     * The name of the OS image. Defaults to `flatcar`.
     */
    osName: string;
    /**
     * This field is deprecated, use `osVersionMin` to configure the version and `osVersionUsed` to get the currently used version instead.
     *
     * @deprecated Use `osVersionMin` to configure the version and `osVersionUsed` to get the currently used version instead. Setting a specific OS image version will cause errors during minor OS upgrades due to forced updates.
     */
    osVersion?: string;
    /**
     * The minimum OS image version. This field will be used to set the minimum OS image version on creation/update of the cluster. If unset, the latest supported OS image version will be used. SKE automatically updates the cluster Kubernetes version if you have set `maintenance.enable_kubernetes_version_updates` to true or if there is a mandatory update, as described in [General information for Kubernetes & OS updates](https://docs.stackit.cloud/products/runtime/kubernetes-engine/basics/version-updates/). To get the current OS image version being used for the node pool, use the read-only `osVersionUsed` field.
     */
    osVersionMin?: string;
    /**
     * Full OS image version used. For example, if 3815.2 was set in `osVersionMin`, this value may result to 3815.2.2. SKE automatically updates the cluster Kubernetes version if you have set `maintenance.enable_kubernetes_version_updates` to true or if there is a mandatory update, as described in [General information for Kubernetes & OS updates](https://docs.stackit.cloud/products/runtime/kubernetes-engine/basics/version-updates/).
     */
    osVersionUsed: string;
    /**
     * Specifies a taint list as defined below.
     */
    taints?: outputs.SkeClusterNodePoolTaint[];
    /**
     * The volume size in GB. Defaults to `20`
     */
    volumeSize: number;
    /**
     * Specifies the volume type. Defaults to `storagePremiumPerf1`.
     */
    volumeType: string;
}

export interface SkeClusterNodePoolTaint {
    /**
     * The taint effect. E.g `PreferNoSchedule`.
     */
    effect: string;
    /**
     * Taint key to be applied to a node.
     */
    key: string;
    /**
     * Taint value corresponding to the taint key.
     */
    value: string;
}

export interface SqlserverflexInstanceFlavor {
    cpu: number;
    description: string;
    id: string;
    ram: number;
}

export interface SqlserverflexInstanceOptions {
    edition: string;
    retentionDays: number;
}

export interface SqlserverflexInstanceStorage {
    class: string;
    size: number;
}

export interface VolumeEncryptionParameters {
    /**
     * UUID of the key within the STACKIT-KMS to use for the encryption.
     */
    kekKeyId: string;
    /**
     * Version of the key within the STACKIT-KMS to use for the encryption.
     */
    kekKeyVersion: number;
    /**
     * UUID of the keyring where the key is located within the STACKTI-KMS.
     */
    kekKeyringId: string;
    /**
     * Optional predefined secret, which will be encrypted against the key-encryption-key within the STACKIT-KMS. If not defined, a random secret will be generated by the API and encrypted against the STACKIT-KMS. If a key-payload is provided here, it must be base64 encoded.
     */
    keyPayloadBase64?: string;
    /**
     * **NOTE:** This field is write-only and its value will not be updated in state as part of read operations.
     * Optional predefined secret, which will be encrypted against the key-encryption-key within the STACKIT-KMS. If not defined, a random secret will be generated by the API and encrypted against the STACKIT-KMS. If a key-payload is provided here, it must be base64 encoded.
     */
    keyPayloadBase64Wo?: string;
    /**
     * Used together with `keyPayloadBase64Wo` to trigger an re-create. Increment this value when an update to `keyPayloadBase64Wo` is required.
     */
    keyPayloadBase64WoVersion?: number;
    /**
     * Service-Account linked to the Key within the STACKIT-KMS.
     */
    serviceAccount: string;
}

export interface VolumeSource {
    /**
     * The ID of the source, e.g. image ID
     */
    id: string;
    /**
     * The type of the source. Possible values are: `volume`, `image`, `snapshot`, `backup`.
     */
    type: string;
}

