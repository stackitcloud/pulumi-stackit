// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Stackit.Inputs
{

    public sealed class ObservabilityInstanceAlertConfigRouteRouteGetArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Whether an alert should continue matching subsequent sibling nodes.
        /// </summary>
        [Input("continue")]
        public Input<bool>? Continue { get; set; }

        [Input("groupBies")]
        private InputList<string>? _groupBies;

        /// <summary>
        /// The labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value '...' as the sole label name, for example: group_by: ['...']. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping.
        /// </summary>
        public InputList<string> GroupBies
        {
            get => _groupBies ?? (_groupBies = new InputList<string>());
            set => _groupBies = value;
        }

        /// <summary>
        /// How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
        /// </summary>
        [Input("groupInterval")]
        public Input<string>? GroupInterval { get; set; }

        /// <summary>
        /// How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
        /// </summary>
        [Input("groupWait")]
        public Input<string>? GroupWait { get; set; }

        [Input("match")]
        private InputMap<string>? _match;

        /// <summary>
        /// A set of equality matchers an alert has to fulfill to match the node. This field is deprecated and will be removed after 10th March 2026, use `matchers` in the `routes` instead
        /// </summary>
        [Obsolete(@"Use `matchers` in the `routes` instead.")]
        public InputMap<string> Match
        {
            get => _match ?? (_match = new InputMap<string>());
            set => _match = value;
        }

        [Input("matchRegex")]
        private InputMap<string>? _matchRegex;

        /// <summary>
        /// A set of regex-matchers an alert has to fulfill to match the node. This field is deprecated and will be removed after 10th March 2026, use `matchers` in the `routes` instead
        /// </summary>
        [Obsolete(@"Use `matchers` in the `routes` instead.")]
        public InputMap<string> MatchRegex
        {
            get => _matchRegex ?? (_matchRegex = new InputMap<string>());
            set => _matchRegex = value;
        }

        [Input("matchers")]
        private InputList<string>? _matchers;

        /// <summary>
        /// A list of matchers that an alert has to fulfill to match the node. A matcher is a string with a syntax inspired by PromQL and OpenMetrics.
        /// </summary>
        public InputList<string> Matchers
        {
            get => _matchers ?? (_matchers = new InputList<string>());
            set => _matchers = value;
        }

        /// <summary>
        /// The name of the receiver to route the alerts to.
        /// </summary>
        [Input("receiver", required: true)]
        public Input<string> Receiver { get; set; } = null!;

        /// <summary>
        /// How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more).
        /// </summary>
        [Input("repeatInterval")]
        public Input<string>? RepeatInterval { get; set; }

        public ObservabilityInstanceAlertConfigRouteRouteGetArgs()
        {
        }
        public static new ObservabilityInstanceAlertConfigRouteRouteGetArgs Empty => new ObservabilityInstanceAlertConfigRouteRouteGetArgs();
    }
}
